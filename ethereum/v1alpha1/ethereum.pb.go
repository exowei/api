// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ethereum/v1alpha1/ethereum.proto

// This package defines the Ethereum API that can be used to
// interact with the Ethereum blockchain.

package v1alpha1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TransactionStatus int32

const (
	TransactionStatus_FAILURE TransactionStatus = 0
	TransactionStatus_SUCCESS TransactionStatus = 1
)

var TransactionStatus_name = map[int32]string{
	0: "FAILURE",
	1: "SUCCESS",
}

var TransactionStatus_value = map[string]int32{
	"FAILURE": 0,
	"SUCCESS": 1,
}

func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}

func (TransactionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{0}
}

type Ether struct {
	Wei                  uint64   `protobuf:"varint,1,opt,name=wei,proto3" json:"wei,omitempty"`
	Eth                  uint64   `protobuf:"varint,2,opt,name=eth,proto3" json:"eth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ether) Reset()         { *m = Ether{} }
func (m *Ether) String() string { return proto.CompactTextString(m) }
func (*Ether) ProtoMessage()    {}
func (*Ether) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{0}
}
func (m *Ether) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ether) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ether.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ether) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ether.Merge(m, src)
}
func (m *Ether) XXX_Size() int {
	return m.Size()
}
func (m *Ether) XXX_DiscardUnknown() {
	xxx_messageInfo_Ether.DiscardUnknown(m)
}

var xxx_messageInfo_Ether proto.InternalMessageInfo

type Transaction struct {
	Hash                 string   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	From                 string   `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   string   `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Input                []byte   `protobuf:"bytes,4,opt,name=input,proto3" json:"input,omitempty"`
	Nonce                uint64   `protobuf:"varint,5,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Gas                  uint32   `protobuf:"varint,6,opt,name=gas,proto3" json:"gas,omitempty"`
	GasPrice             *Ether   `protobuf:"bytes,7,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	Value                *Ether   `protobuf:"bytes,8,opt,name=value,proto3" json:"value,omitempty"`
	BlockHash            string   `protobuf:"bytes,9,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	BlockNumber          uint32   `protobuf:"varint,10,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	TransactionIndex     uint32   `protobuf:"varint,11,opt,name=transaction_index,json=transactionIndex,proto3" json:"transaction_index,omitempty"`
	V                    []byte   `protobuf:"bytes,12,opt,name=v,proto3" json:"v,omitempty"`
	R                    []byte   `protobuf:"bytes,13,opt,name=r,proto3" json:"r,omitempty"`
	S                    []byte   `protobuf:"bytes,14,opt,name=s,proto3" json:"s,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{1}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

type Log struct {
	LogIndex             uint64   `protobuf:"varint,1,opt,name=log_index,json=logIndex,proto3" json:"log_index,omitempty"`
	BlockNumber          uint32   `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	BlockHash            string   `protobuf:"bytes,3,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	TransactionHash      string   `protobuf:"bytes,4,opt,name=transaction_hash,json=transactionHash,proto3" json:"transaction_hash,omitempty"`
	TransactionIndex     uint32   `protobuf:"varint,5,opt,name=transaction_index,json=transactionIndex,proto3" json:"transaction_index,omitempty"`
	Address              string   `protobuf:"bytes,6,opt,name=address,proto3" json:"address,omitempty"`
	Data                 []byte   `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
	Topics               []string `protobuf:"bytes,8,rep,name=topics,proto3" json:"topics,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{2}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

type TransactionReceipt struct {
	TransactionHash      string            `protobuf:"bytes,1,opt,name=transaction_hash,json=transactionHash,proto3" json:"transaction_hash,omitempty"`
	TransactionIndex     uint32            `protobuf:"varint,2,opt,name=transaction_index,json=transactionIndex,proto3" json:"transaction_index,omitempty"`
	BlockHash            string            `protobuf:"bytes,3,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	BlockNumber          uint32            `protobuf:"varint,4,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	From                 string            `protobuf:"bytes,5,opt,name=from,proto3" json:"from,omitempty"`
	To                   string            `protobuf:"bytes,6,opt,name=to,proto3" json:"to,omitempty"`
	CumulativeGasUsed    uint32            `protobuf:"varint,7,opt,name=cumulative_gas_used,json=cumulativeGasUsed,proto3" json:"cumulative_gas_used,omitempty"`
	GasUsed              uint32            `protobuf:"varint,8,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	ContractAddress      string            `protobuf:"bytes,9,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	Logs                 []*Log            `protobuf:"bytes,10,rep,name=logs,proto3" json:"logs,omitempty"`
	LogsBloom            string            `protobuf:"bytes,11,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	Root                 string            `protobuf:"bytes,12,opt,name=root,proto3" json:"root,omitempty"`
	Status               TransactionStatus `protobuf:"varint,13,opt,name=status,proto3,enum=exowei.ethereum.v1alpha1.TransactionStatus" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TransactionReceipt) Reset()         { *m = TransactionReceipt{} }
func (m *TransactionReceipt) String() string { return proto.CompactTextString(m) }
func (*TransactionReceipt) ProtoMessage()    {}
func (*TransactionReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{3}
}
func (m *TransactionReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionReceipt.Merge(m, src)
}
func (m *TransactionReceipt) XXX_Size() int {
	return m.Size()
}
func (m *TransactionReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionReceipt proto.InternalMessageInfo

type Block struct {
	Number               uint32           `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Hash                 string           `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	ParentHash           string           `protobuf:"bytes,3,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	Nonce                string           `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Sha3Uncles           string           `protobuf:"bytes,5,opt,name=sha3_uncles,json=sha3Uncles,proto3" json:"sha3_uncles,omitempty"`
	LogsBloom            string           `protobuf:"bytes,6,opt,name=logs_bloom,json=logsBloom,proto3" json:"logs_bloom,omitempty"`
	TransactionsRoot     string           `protobuf:"bytes,7,opt,name=transactions_root,json=transactionsRoot,proto3" json:"transactions_root,omitempty"`
	StateRoot            string           `protobuf:"bytes,8,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	ReceiptsRoot         string           `protobuf:"bytes,9,opt,name=receipts_root,json=receiptsRoot,proto3" json:"receipts_root,omitempty"`
	Miner                string           `protobuf:"bytes,10,opt,name=miner,proto3" json:"miner,omitempty"`
	Difficulty           string           `protobuf:"bytes,11,opt,name=difficulty,proto3" json:"difficulty,omitempty"`
	TotalDifficulty      string           `protobuf:"bytes,12,opt,name=total_difficulty,json=totalDifficulty,proto3" json:"total_difficulty,omitempty"`
	ExtraData            []byte           `protobuf:"bytes,13,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	BlockSize            uint32           `protobuf:"varint,14,opt,name=block_size,json=blockSize,proto3" json:"block_size,omitempty"`
	GasLimit             uint32           `protobuf:"varint,15,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	GasUsed              uint32           `protobuf:"varint,16,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	Timestamp            *types.Timestamp `protobuf:"bytes,17,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Transactions         []*Transaction   `protobuf:"bytes,18,rep,name=transactions,proto3" json:"transactions,omitempty"`
	TransactionHashes    []string         `protobuf:"bytes,19,rep,name=transaction_hashes,json=transactionHashes,proto3" json:"transaction_hashes,omitempty"`
	Uncles               []string         `protobuf:"bytes,20,rep,name=uncles,proto3" json:"uncles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{4}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

type ProtocolVersionRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtocolVersionRequest) Reset()         { *m = ProtocolVersionRequest{} }
func (m *ProtocolVersionRequest) String() string { return proto.CompactTextString(m) }
func (*ProtocolVersionRequest) ProtoMessage()    {}
func (*ProtocolVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{5}
}
func (m *ProtocolVersionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolVersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolVersionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolVersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolVersionRequest.Merge(m, src)
}
func (m *ProtocolVersionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolVersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolVersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolVersionRequest proto.InternalMessageInfo

type ProtocolVersionResponse struct {
	ProtocolVersion      uint32   `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtocolVersionResponse) Reset()         { *m = ProtocolVersionResponse{} }
func (m *ProtocolVersionResponse) String() string { return proto.CompactTextString(m) }
func (*ProtocolVersionResponse) ProtoMessage()    {}
func (*ProtocolVersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{6}
}
func (m *ProtocolVersionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolVersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolVersionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolVersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolVersionResponse.Merge(m, src)
}
func (m *ProtocolVersionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolVersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolVersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolVersionResponse proto.InternalMessageInfo

type SyncingRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncingRequest) Reset()         { *m = SyncingRequest{} }
func (m *SyncingRequest) String() string { return proto.CompactTextString(m) }
func (*SyncingRequest) ProtoMessage()    {}
func (*SyncingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{7}
}
func (m *SyncingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncingRequest.Merge(m, src)
}
func (m *SyncingRequest) XXX_Size() int {
	return m.Size()
}
func (m *SyncingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncingRequest proto.InternalMessageInfo

type SyncingResponse struct {
	Syncing              bool     `protobuf:"varint,1,opt,name=syncing,proto3" json:"syncing,omitempty"`
	StartingBlock        uint32   `protobuf:"varint,2,opt,name=starting_block,json=startingBlock,proto3" json:"starting_block,omitempty"`
	CurrentBlock         uint32   `protobuf:"varint,3,opt,name=current_block,json=currentBlock,proto3" json:"current_block,omitempty"`
	HighestBlock         uint32   `protobuf:"varint,4,opt,name=highest_block,json=highestBlock,proto3" json:"highest_block,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncingResponse) Reset()         { *m = SyncingResponse{} }
func (m *SyncingResponse) String() string { return proto.CompactTextString(m) }
func (*SyncingResponse) ProtoMessage()    {}
func (*SyncingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{8}
}
func (m *SyncingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncingResponse.Merge(m, src)
}
func (m *SyncingResponse) XXX_Size() int {
	return m.Size()
}
func (m *SyncingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncingResponse proto.InternalMessageInfo

type GasPriceRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GasPriceRequest) Reset()         { *m = GasPriceRequest{} }
func (m *GasPriceRequest) String() string { return proto.CompactTextString(m) }
func (*GasPriceRequest) ProtoMessage()    {}
func (*GasPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{9}
}
func (m *GasPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPriceRequest.Merge(m, src)
}
func (m *GasPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GasPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GasPriceRequest proto.InternalMessageInfo

type GasPriceResponse struct {
	GasPrice             *Ether   `protobuf:"bytes,1,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GasPriceResponse) Reset()         { *m = GasPriceResponse{} }
func (m *GasPriceResponse) String() string { return proto.CompactTextString(m) }
func (*GasPriceResponse) ProtoMessage()    {}
func (*GasPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{10}
}
func (m *GasPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPriceResponse.Merge(m, src)
}
func (m *GasPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GasPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GasPriceResponse proto.InternalMessageInfo

type BlockNumberRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockNumberRequest) Reset()         { *m = BlockNumberRequest{} }
func (m *BlockNumberRequest) String() string { return proto.CompactTextString(m) }
func (*BlockNumberRequest) ProtoMessage()    {}
func (*BlockNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{11}
}
func (m *BlockNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockNumberRequest.Merge(m, src)
}
func (m *BlockNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockNumberRequest proto.InternalMessageInfo

type BlockNumberResponse struct {
	BlockNumber          uint32   `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockNumberResponse) Reset()         { *m = BlockNumberResponse{} }
func (m *BlockNumberResponse) String() string { return proto.CompactTextString(m) }
func (*BlockNumberResponse) ProtoMessage()    {}
func (*BlockNumberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{12}
}
func (m *BlockNumberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockNumberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockNumberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockNumberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockNumberResponse.Merge(m, src)
}
func (m *BlockNumberResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockNumberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockNumberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockNumberResponse proto.InternalMessageInfo

type GetBalanceRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	BlockNumber          uint32   `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBalanceRequest) Reset()         { *m = GetBalanceRequest{} }
func (m *GetBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*GetBalanceRequest) ProtoMessage()    {}
func (*GetBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{13}
}
func (m *GetBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceRequest.Merge(m, src)
}
func (m *GetBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceRequest proto.InternalMessageInfo

type GetBalanceResponse struct {
	Balance              *Ether   `protobuf:"bytes,1,opt,name=balance,proto3" json:"balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBalanceResponse) Reset()         { *m = GetBalanceResponse{} }
func (m *GetBalanceResponse) String() string { return proto.CompactTextString(m) }
func (*GetBalanceResponse) ProtoMessage()    {}
func (*GetBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{14}
}
func (m *GetBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBalanceResponse.Merge(m, src)
}
func (m *GetBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBalanceResponse proto.InternalMessageInfo

type GetStorageAtRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Offset               uint64   `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	BlockNumber          uint32   `protobuf:"varint,3,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStorageAtRequest) Reset()         { *m = GetStorageAtRequest{} }
func (m *GetStorageAtRequest) String() string { return proto.CompactTextString(m) }
func (*GetStorageAtRequest) ProtoMessage()    {}
func (*GetStorageAtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{15}
}
func (m *GetStorageAtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStorageAtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStorageAtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStorageAtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStorageAtRequest.Merge(m, src)
}
func (m *GetStorageAtRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStorageAtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStorageAtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStorageAtRequest proto.InternalMessageInfo

type GetStorageAtResponse struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStorageAtResponse) Reset()         { *m = GetStorageAtResponse{} }
func (m *GetStorageAtResponse) String() string { return proto.CompactTextString(m) }
func (*GetStorageAtResponse) ProtoMessage()    {}
func (*GetStorageAtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{16}
}
func (m *GetStorageAtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStorageAtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStorageAtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStorageAtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStorageAtResponse.Merge(m, src)
}
func (m *GetStorageAtResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetStorageAtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStorageAtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStorageAtResponse proto.InternalMessageInfo

type GetTransactionCountRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	BlockNumber          uint32   `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionCountRequest) Reset()         { *m = GetTransactionCountRequest{} }
func (m *GetTransactionCountRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransactionCountRequest) ProtoMessage()    {}
func (*GetTransactionCountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{17}
}
func (m *GetTransactionCountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionCountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionCountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionCountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionCountRequest.Merge(m, src)
}
func (m *GetTransactionCountRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionCountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionCountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionCountRequest proto.InternalMessageInfo

type GetTransactionCountResponse struct {
	TransactionCount     uint32   `protobuf:"varint,1,opt,name=transaction_count,json=transactionCount,proto3" json:"transaction_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionCountResponse) Reset()         { *m = GetTransactionCountResponse{} }
func (m *GetTransactionCountResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransactionCountResponse) ProtoMessage()    {}
func (*GetTransactionCountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{18}
}
func (m *GetTransactionCountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionCountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionCountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionCountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionCountResponse.Merge(m, src)
}
func (m *GetTransactionCountResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionCountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionCountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionCountResponse proto.InternalMessageInfo

type GetBlockTransactionCountByHashRequest struct {
	BlockHash            string   `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockTransactionCountByHashRequest) Reset()         { *m = GetBlockTransactionCountByHashRequest{} }
func (m *GetBlockTransactionCountByHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockTransactionCountByHashRequest) ProtoMessage()    {}
func (*GetBlockTransactionCountByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{19}
}
func (m *GetBlockTransactionCountByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockTransactionCountByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockTransactionCountByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockTransactionCountByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockTransactionCountByHashRequest.Merge(m, src)
}
func (m *GetBlockTransactionCountByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockTransactionCountByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockTransactionCountByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockTransactionCountByHashRequest proto.InternalMessageInfo

type GetBlockTransactionCountByHashResponse struct {
	TransactionCount     uint32   `protobuf:"varint,1,opt,name=transaction_count,json=transactionCount,proto3" json:"transaction_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockTransactionCountByHashResponse) Reset() {
	*m = GetBlockTransactionCountByHashResponse{}
}
func (m *GetBlockTransactionCountByHashResponse) String() string { return proto.CompactTextString(m) }
func (*GetBlockTransactionCountByHashResponse) ProtoMessage()    {}
func (*GetBlockTransactionCountByHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{20}
}
func (m *GetBlockTransactionCountByHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockTransactionCountByHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockTransactionCountByHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockTransactionCountByHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockTransactionCountByHashResponse.Merge(m, src)
}
func (m *GetBlockTransactionCountByHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockTransactionCountByHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockTransactionCountByHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockTransactionCountByHashResponse proto.InternalMessageInfo

type GetBlockTransactionCountByNumberRequest struct {
	BlockNumber          uint32   `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockTransactionCountByNumberRequest) Reset() {
	*m = GetBlockTransactionCountByNumberRequest{}
}
func (m *GetBlockTransactionCountByNumberRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockTransactionCountByNumberRequest) ProtoMessage()    {}
func (*GetBlockTransactionCountByNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{21}
}
func (m *GetBlockTransactionCountByNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockTransactionCountByNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockTransactionCountByNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockTransactionCountByNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockTransactionCountByNumberRequest.Merge(m, src)
}
func (m *GetBlockTransactionCountByNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockTransactionCountByNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockTransactionCountByNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockTransactionCountByNumberRequest proto.InternalMessageInfo

type GetBlockTransactionCountByNumberResponse struct {
	TransactionCount     uint32   `protobuf:"varint,1,opt,name=transaction_count,json=transactionCount,proto3" json:"transaction_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBlockTransactionCountByNumberResponse) Reset() {
	*m = GetBlockTransactionCountByNumberResponse{}
}
func (m *GetBlockTransactionCountByNumberResponse) String() string { return proto.CompactTextString(m) }
func (*GetBlockTransactionCountByNumberResponse) ProtoMessage()    {}
func (*GetBlockTransactionCountByNumberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{22}
}
func (m *GetBlockTransactionCountByNumberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockTransactionCountByNumberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockTransactionCountByNumberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockTransactionCountByNumberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockTransactionCountByNumberResponse.Merge(m, src)
}
func (m *GetBlockTransactionCountByNumberResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockTransactionCountByNumberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockTransactionCountByNumberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockTransactionCountByNumberResponse proto.InternalMessageInfo

type GetUncleCountByBlockHashRequest struct {
	BlockHash            string   `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUncleCountByBlockHashRequest) Reset()         { *m = GetUncleCountByBlockHashRequest{} }
func (m *GetUncleCountByBlockHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetUncleCountByBlockHashRequest) ProtoMessage()    {}
func (*GetUncleCountByBlockHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{23}
}
func (m *GetUncleCountByBlockHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUncleCountByBlockHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUncleCountByBlockHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUncleCountByBlockHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUncleCountByBlockHashRequest.Merge(m, src)
}
func (m *GetUncleCountByBlockHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUncleCountByBlockHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUncleCountByBlockHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUncleCountByBlockHashRequest proto.InternalMessageInfo

type GetUncleCountByBlockHashResponse struct {
	UncleCount           uint32   `protobuf:"varint,1,opt,name=uncle_count,json=uncleCount,proto3" json:"uncle_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUncleCountByBlockHashResponse) Reset()         { *m = GetUncleCountByBlockHashResponse{} }
func (m *GetUncleCountByBlockHashResponse) String() string { return proto.CompactTextString(m) }
func (*GetUncleCountByBlockHashResponse) ProtoMessage()    {}
func (*GetUncleCountByBlockHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{24}
}
func (m *GetUncleCountByBlockHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUncleCountByBlockHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUncleCountByBlockHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUncleCountByBlockHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUncleCountByBlockHashResponse.Merge(m, src)
}
func (m *GetUncleCountByBlockHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetUncleCountByBlockHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUncleCountByBlockHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUncleCountByBlockHashResponse proto.InternalMessageInfo

type GetUncleCountByBlockNumberRequest struct {
	BlockNumber          uint32   `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUncleCountByBlockNumberRequest) Reset()         { *m = GetUncleCountByBlockNumberRequest{} }
func (m *GetUncleCountByBlockNumberRequest) String() string { return proto.CompactTextString(m) }
func (*GetUncleCountByBlockNumberRequest) ProtoMessage()    {}
func (*GetUncleCountByBlockNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{25}
}
func (m *GetUncleCountByBlockNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUncleCountByBlockNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUncleCountByBlockNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUncleCountByBlockNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUncleCountByBlockNumberRequest.Merge(m, src)
}
func (m *GetUncleCountByBlockNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUncleCountByBlockNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUncleCountByBlockNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUncleCountByBlockNumberRequest proto.InternalMessageInfo

type GetUncleCountByBlockNumberResponse struct {
	UncleCount           uint32   `protobuf:"varint,1,opt,name=uncle_count,json=uncleCount,proto3" json:"uncle_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUncleCountByBlockNumberResponse) Reset()         { *m = GetUncleCountByBlockNumberResponse{} }
func (m *GetUncleCountByBlockNumberResponse) String() string { return proto.CompactTextString(m) }
func (*GetUncleCountByBlockNumberResponse) ProtoMessage()    {}
func (*GetUncleCountByBlockNumberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{26}
}
func (m *GetUncleCountByBlockNumberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUncleCountByBlockNumberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUncleCountByBlockNumberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUncleCountByBlockNumberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUncleCountByBlockNumberResponse.Merge(m, src)
}
func (m *GetUncleCountByBlockNumberResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetUncleCountByBlockNumberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUncleCountByBlockNumberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUncleCountByBlockNumberResponse proto.InternalMessageInfo

type GetCodeRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCodeRequest) Reset()         { *m = GetCodeRequest{} }
func (m *GetCodeRequest) String() string { return proto.CompactTextString(m) }
func (*GetCodeRequest) ProtoMessage()    {}
func (*GetCodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{27}
}
func (m *GetCodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCodeRequest.Merge(m, src)
}
func (m *GetCodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCodeRequest proto.InternalMessageInfo

type GetCodeResponse struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCodeResponse) Reset()         { *m = GetCodeResponse{} }
func (m *GetCodeResponse) String() string { return proto.CompactTextString(m) }
func (*GetCodeResponse) ProtoMessage()    {}
func (*GetCodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{28}
}
func (m *GetCodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCodeResponse.Merge(m, src)
}
func (m *GetCodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCodeResponse proto.InternalMessageInfo

type SendRawTransactionRequest struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendRawTransactionRequest) Reset()         { *m = SendRawTransactionRequest{} }
func (m *SendRawTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*SendRawTransactionRequest) ProtoMessage()    {}
func (*SendRawTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{29}
}
func (m *SendRawTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendRawTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendRawTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendRawTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendRawTransactionRequest.Merge(m, src)
}
func (m *SendRawTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendRawTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendRawTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendRawTransactionRequest proto.InternalMessageInfo

type SendRawTransactionResponse struct {
	TransactionHash      string   `protobuf:"bytes,1,opt,name=transaction_hash,json=transactionHash,proto3" json:"transaction_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendRawTransactionResponse) Reset()         { *m = SendRawTransactionResponse{} }
func (m *SendRawTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*SendRawTransactionResponse) ProtoMessage()    {}
func (*SendRawTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{30}
}
func (m *SendRawTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendRawTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendRawTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendRawTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendRawTransactionResponse.Merge(m, src)
}
func (m *SendRawTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendRawTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendRawTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendRawTransactionResponse proto.InternalMessageInfo

type CallRequest struct {
	Transaction          *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CallRequest) Reset()         { *m = CallRequest{} }
func (m *CallRequest) String() string { return proto.CompactTextString(m) }
func (*CallRequest) ProtoMessage()    {}
func (*CallRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{31}
}
func (m *CallRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallRequest.Merge(m, src)
}
func (m *CallRequest) XXX_Size() int {
	return m.Size()
}
func (m *CallRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CallRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CallRequest proto.InternalMessageInfo

type CallResponse struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CallResponse) Reset()         { *m = CallResponse{} }
func (m *CallResponse) String() string { return proto.CompactTextString(m) }
func (*CallResponse) ProtoMessage()    {}
func (*CallResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{32}
}
func (m *CallResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallResponse.Merge(m, src)
}
func (m *CallResponse) XXX_Size() int {
	return m.Size()
}
func (m *CallResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CallResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CallResponse proto.InternalMessageInfo

type EstimateGasRequest struct {
	Transaction          *Transaction `protobuf:"bytes,1,opt,name=transaction,proto3" json:"transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *EstimateGasRequest) Reset()         { *m = EstimateGasRequest{} }
func (m *EstimateGasRequest) String() string { return proto.CompactTextString(m) }
func (*EstimateGasRequest) ProtoMessage()    {}
func (*EstimateGasRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{33}
}
func (m *EstimateGasRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateGasRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateGasRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateGasRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateGasRequest.Merge(m, src)
}
func (m *EstimateGasRequest) XXX_Size() int {
	return m.Size()
}
func (m *EstimateGasRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateGasRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateGasRequest proto.InternalMessageInfo

type EstimateGasResponse struct {
	EstimatedGas         uint32   `protobuf:"varint,1,opt,name=estimated_gas,json=estimatedGas,proto3" json:"estimated_gas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EstimateGasResponse) Reset()         { *m = EstimateGasResponse{} }
func (m *EstimateGasResponse) String() string { return proto.CompactTextString(m) }
func (*EstimateGasResponse) ProtoMessage()    {}
func (*EstimateGasResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{34}
}
func (m *EstimateGasResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateGasResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateGasResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateGasResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateGasResponse.Merge(m, src)
}
func (m *EstimateGasResponse) XXX_Size() int {
	return m.Size()
}
func (m *EstimateGasResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateGasResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateGasResponse proto.InternalMessageInfo

type GetBlockByHashRequest struct {
	BlockHash               string   `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	IncludeFullTransactions bool     `protobuf:"varint,2,opt,name=include_full_transactions,json=includeFullTransactions,proto3" json:"include_full_transactions,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *GetBlockByHashRequest) Reset()         { *m = GetBlockByHashRequest{} }
func (m *GetBlockByHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockByHashRequest) ProtoMessage()    {}
func (*GetBlockByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{35}
}
func (m *GetBlockByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockByHashRequest.Merge(m, src)
}
func (m *GetBlockByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockByHashRequest proto.InternalMessageInfo

type GetBlockByNumberRequest struct {
	BlockNumber             uint32   `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	IncludeFullTransactions bool     `protobuf:"varint,3,opt,name=include_full_transactions,json=includeFullTransactions,proto3" json:"include_full_transactions,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *GetBlockByNumberRequest) Reset()         { *m = GetBlockByNumberRequest{} }
func (m *GetBlockByNumberRequest) String() string { return proto.CompactTextString(m) }
func (*GetBlockByNumberRequest) ProtoMessage()    {}
func (*GetBlockByNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{36}
}
func (m *GetBlockByNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBlockByNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBlockByNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBlockByNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBlockByNumberRequest.Merge(m, src)
}
func (m *GetBlockByNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetBlockByNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBlockByNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBlockByNumberRequest proto.InternalMessageInfo

type ListTransactionsRequest struct {
	Account              string   `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	PageSize             uint32   `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string   `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListTransactionsRequest) Reset()         { *m = ListTransactionsRequest{} }
func (m *ListTransactionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListTransactionsRequest) ProtoMessage()    {}
func (*ListTransactionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{37}
}
func (m *ListTransactionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTransactionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTransactionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTransactionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTransactionsRequest.Merge(m, src)
}
func (m *ListTransactionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListTransactionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTransactionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTransactionsRequest proto.InternalMessageInfo

type ListTransactionsResponse struct {
	Transactions         []*Transaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListTransactionsResponse) Reset()         { *m = ListTransactionsResponse{} }
func (m *ListTransactionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListTransactionsResponse) ProtoMessage()    {}
func (*ListTransactionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{38}
}
func (m *ListTransactionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTransactionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTransactionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTransactionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTransactionsResponse.Merge(m, src)
}
func (m *ListTransactionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListTransactionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTransactionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTransactionsResponse proto.InternalMessageInfo

type GetTransactionByHashRequest struct {
	TransactionHash      string   `protobuf:"bytes,1,opt,name=transaction_hash,json=transactionHash,proto3" json:"transaction_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionByHashRequest) Reset()         { *m = GetTransactionByHashRequest{} }
func (m *GetTransactionByHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransactionByHashRequest) ProtoMessage()    {}
func (*GetTransactionByHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{39}
}
func (m *GetTransactionByHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionByHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionByHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionByHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionByHashRequest.Merge(m, src)
}
func (m *GetTransactionByHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionByHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionByHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionByHashRequest proto.InternalMessageInfo

type GetTransactionByBlockHashAndIndexRequest struct {
	BlockHash            string   `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	TransactionIndex     uint32   `protobuf:"varint,2,opt,name=transaction_index,json=transactionIndex,proto3" json:"transaction_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionByBlockHashAndIndexRequest) Reset() {
	*m = GetTransactionByBlockHashAndIndexRequest{}
}
func (m *GetTransactionByBlockHashAndIndexRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransactionByBlockHashAndIndexRequest) ProtoMessage()    {}
func (*GetTransactionByBlockHashAndIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{40}
}
func (m *GetTransactionByBlockHashAndIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionByBlockHashAndIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionByBlockHashAndIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionByBlockHashAndIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionByBlockHashAndIndexRequest.Merge(m, src)
}
func (m *GetTransactionByBlockHashAndIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionByBlockHashAndIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionByBlockHashAndIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionByBlockHashAndIndexRequest proto.InternalMessageInfo

type GetTransactionByBlockNumberAndIndexRequest struct {
	BlockNumber          uint32   `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	TransactionIndex     uint32   `protobuf:"varint,2,opt,name=transaction_index,json=transactionIndex,proto3" json:"transaction_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionByBlockNumberAndIndexRequest) Reset() {
	*m = GetTransactionByBlockNumberAndIndexRequest{}
}
func (m *GetTransactionByBlockNumberAndIndexRequest) String() string {
	return proto.CompactTextString(m)
}
func (*GetTransactionByBlockNumberAndIndexRequest) ProtoMessage() {}
func (*GetTransactionByBlockNumberAndIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{41}
}
func (m *GetTransactionByBlockNumberAndIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionByBlockNumberAndIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionByBlockNumberAndIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionByBlockNumberAndIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionByBlockNumberAndIndexRequest.Merge(m, src)
}
func (m *GetTransactionByBlockNumberAndIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionByBlockNumberAndIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionByBlockNumberAndIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionByBlockNumberAndIndexRequest proto.InternalMessageInfo

type SubscribeTransactionsRequest struct {
	Account              string   `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeTransactionsRequest) Reset()         { *m = SubscribeTransactionsRequest{} }
func (m *SubscribeTransactionsRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeTransactionsRequest) ProtoMessage()    {}
func (*SubscribeTransactionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{42}
}
func (m *SubscribeTransactionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeTransactionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeTransactionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeTransactionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeTransactionsRequest.Merge(m, src)
}
func (m *SubscribeTransactionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeTransactionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeTransactionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeTransactionsRequest proto.InternalMessageInfo

type GetTransactionReceiptRequest struct {
	TransactionHash      string   `protobuf:"bytes,1,opt,name=transaction_hash,json=transactionHash,proto3" json:"transaction_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTransactionReceiptRequest) Reset()         { *m = GetTransactionReceiptRequest{} }
func (m *GetTransactionReceiptRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransactionReceiptRequest) ProtoMessage()    {}
func (*GetTransactionReceiptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{43}
}
func (m *GetTransactionReceiptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionReceiptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionReceiptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionReceiptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionReceiptRequest.Merge(m, src)
}
func (m *GetTransactionReceiptRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionReceiptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionReceiptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionReceiptRequest proto.InternalMessageInfo

type PendingTransactionsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PendingTransactionsRequest) Reset()         { *m = PendingTransactionsRequest{} }
func (m *PendingTransactionsRequest) String() string { return proto.CompactTextString(m) }
func (*PendingTransactionsRequest) ProtoMessage()    {}
func (*PendingTransactionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{44}
}
func (m *PendingTransactionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingTransactionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingTransactionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingTransactionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingTransactionsRequest.Merge(m, src)
}
func (m *PendingTransactionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *PendingTransactionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingTransactionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PendingTransactionsRequest proto.InternalMessageInfo

type PendingTransactionsResponse struct {
	Transactions         []*Transaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PendingTransactionsResponse) Reset()         { *m = PendingTransactionsResponse{} }
func (m *PendingTransactionsResponse) String() string { return proto.CompactTextString(m) }
func (*PendingTransactionsResponse) ProtoMessage()    {}
func (*PendingTransactionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{45}
}
func (m *PendingTransactionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingTransactionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingTransactionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingTransactionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingTransactionsResponse.Merge(m, src)
}
func (m *PendingTransactionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *PendingTransactionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingTransactionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PendingTransactionsResponse proto.InternalMessageInfo

type GetUncleByBlockHashAndIndexRequest struct {
	BlockHash            string   `protobuf:"bytes,1,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	UncleIndex           uint32   `protobuf:"varint,2,opt,name=uncle_index,json=uncleIndex,proto3" json:"uncle_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUncleByBlockHashAndIndexRequest) Reset()         { *m = GetUncleByBlockHashAndIndexRequest{} }
func (m *GetUncleByBlockHashAndIndexRequest) String() string { return proto.CompactTextString(m) }
func (*GetUncleByBlockHashAndIndexRequest) ProtoMessage()    {}
func (*GetUncleByBlockHashAndIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{46}
}
func (m *GetUncleByBlockHashAndIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUncleByBlockHashAndIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUncleByBlockHashAndIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUncleByBlockHashAndIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUncleByBlockHashAndIndexRequest.Merge(m, src)
}
func (m *GetUncleByBlockHashAndIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUncleByBlockHashAndIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUncleByBlockHashAndIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUncleByBlockHashAndIndexRequest proto.InternalMessageInfo

type GetUncleByBlockNumberAndIndexRequest struct {
	BlockNumber          uint32   `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	UncleIndex           uint32   `protobuf:"varint,2,opt,name=uncle_index,json=uncleIndex,proto3" json:"uncle_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUncleByBlockNumberAndIndexRequest) Reset()         { *m = GetUncleByBlockNumberAndIndexRequest{} }
func (m *GetUncleByBlockNumberAndIndexRequest) String() string { return proto.CompactTextString(m) }
func (*GetUncleByBlockNumberAndIndexRequest) ProtoMessage()    {}
func (*GetUncleByBlockNumberAndIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d228465d76da121, []int{47}
}
func (m *GetUncleByBlockNumberAndIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUncleByBlockNumberAndIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUncleByBlockNumberAndIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUncleByBlockNumberAndIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUncleByBlockNumberAndIndexRequest.Merge(m, src)
}
func (m *GetUncleByBlockNumberAndIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUncleByBlockNumberAndIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUncleByBlockNumberAndIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUncleByBlockNumberAndIndexRequest proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("exowei.ethereum.v1alpha1.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
	proto.RegisterType((*Ether)(nil), "exowei.ethereum.v1alpha1.Ether")
	proto.RegisterType((*Transaction)(nil), "exowei.ethereum.v1alpha1.Transaction")
	proto.RegisterType((*Log)(nil), "exowei.ethereum.v1alpha1.Log")
	proto.RegisterType((*TransactionReceipt)(nil), "exowei.ethereum.v1alpha1.TransactionReceipt")
	proto.RegisterType((*Block)(nil), "exowei.ethereum.v1alpha1.Block")
	proto.RegisterType((*ProtocolVersionRequest)(nil), "exowei.ethereum.v1alpha1.ProtocolVersionRequest")
	proto.RegisterType((*ProtocolVersionResponse)(nil), "exowei.ethereum.v1alpha1.ProtocolVersionResponse")
	proto.RegisterType((*SyncingRequest)(nil), "exowei.ethereum.v1alpha1.SyncingRequest")
	proto.RegisterType((*SyncingResponse)(nil), "exowei.ethereum.v1alpha1.SyncingResponse")
	proto.RegisterType((*GasPriceRequest)(nil), "exowei.ethereum.v1alpha1.GasPriceRequest")
	proto.RegisterType((*GasPriceResponse)(nil), "exowei.ethereum.v1alpha1.GasPriceResponse")
	proto.RegisterType((*BlockNumberRequest)(nil), "exowei.ethereum.v1alpha1.BlockNumberRequest")
	proto.RegisterType((*BlockNumberResponse)(nil), "exowei.ethereum.v1alpha1.BlockNumberResponse")
	proto.RegisterType((*GetBalanceRequest)(nil), "exowei.ethereum.v1alpha1.GetBalanceRequest")
	proto.RegisterType((*GetBalanceResponse)(nil), "exowei.ethereum.v1alpha1.GetBalanceResponse")
	proto.RegisterType((*GetStorageAtRequest)(nil), "exowei.ethereum.v1alpha1.GetStorageAtRequest")
	proto.RegisterType((*GetStorageAtResponse)(nil), "exowei.ethereum.v1alpha1.GetStorageAtResponse")
	proto.RegisterType((*GetTransactionCountRequest)(nil), "exowei.ethereum.v1alpha1.GetTransactionCountRequest")
	proto.RegisterType((*GetTransactionCountResponse)(nil), "exowei.ethereum.v1alpha1.GetTransactionCountResponse")
	proto.RegisterType((*GetBlockTransactionCountByHashRequest)(nil), "exowei.ethereum.v1alpha1.GetBlockTransactionCountByHashRequest")
	proto.RegisterType((*GetBlockTransactionCountByHashResponse)(nil), "exowei.ethereum.v1alpha1.GetBlockTransactionCountByHashResponse")
	proto.RegisterType((*GetBlockTransactionCountByNumberRequest)(nil), "exowei.ethereum.v1alpha1.GetBlockTransactionCountByNumberRequest")
	proto.RegisterType((*GetBlockTransactionCountByNumberResponse)(nil), "exowei.ethereum.v1alpha1.GetBlockTransactionCountByNumberResponse")
	proto.RegisterType((*GetUncleCountByBlockHashRequest)(nil), "exowei.ethereum.v1alpha1.GetUncleCountByBlockHashRequest")
	proto.RegisterType((*GetUncleCountByBlockHashResponse)(nil), "exowei.ethereum.v1alpha1.GetUncleCountByBlockHashResponse")
	proto.RegisterType((*GetUncleCountByBlockNumberRequest)(nil), "exowei.ethereum.v1alpha1.GetUncleCountByBlockNumberRequest")
	proto.RegisterType((*GetUncleCountByBlockNumberResponse)(nil), "exowei.ethereum.v1alpha1.GetUncleCountByBlockNumberResponse")
	proto.RegisterType((*GetCodeRequest)(nil), "exowei.ethereum.v1alpha1.GetCodeRequest")
	proto.RegisterType((*GetCodeResponse)(nil), "exowei.ethereum.v1alpha1.GetCodeResponse")
	proto.RegisterType((*SendRawTransactionRequest)(nil), "exowei.ethereum.v1alpha1.SendRawTransactionRequest")
	proto.RegisterType((*SendRawTransactionResponse)(nil), "exowei.ethereum.v1alpha1.SendRawTransactionResponse")
	proto.RegisterType((*CallRequest)(nil), "exowei.ethereum.v1alpha1.CallRequest")
	proto.RegisterType((*CallResponse)(nil), "exowei.ethereum.v1alpha1.CallResponse")
	proto.RegisterType((*EstimateGasRequest)(nil), "exowei.ethereum.v1alpha1.EstimateGasRequest")
	proto.RegisterType((*EstimateGasResponse)(nil), "exowei.ethereum.v1alpha1.EstimateGasResponse")
	proto.RegisterType((*GetBlockByHashRequest)(nil), "exowei.ethereum.v1alpha1.GetBlockByHashRequest")
	proto.RegisterType((*GetBlockByNumberRequest)(nil), "exowei.ethereum.v1alpha1.GetBlockByNumberRequest")
	proto.RegisterType((*ListTransactionsRequest)(nil), "exowei.ethereum.v1alpha1.ListTransactionsRequest")
	proto.RegisterType((*ListTransactionsResponse)(nil), "exowei.ethereum.v1alpha1.ListTransactionsResponse")
	proto.RegisterType((*GetTransactionByHashRequest)(nil), "exowei.ethereum.v1alpha1.GetTransactionByHashRequest")
	proto.RegisterType((*GetTransactionByBlockHashAndIndexRequest)(nil), "exowei.ethereum.v1alpha1.GetTransactionByBlockHashAndIndexRequest")
	proto.RegisterType((*GetTransactionByBlockNumberAndIndexRequest)(nil), "exowei.ethereum.v1alpha1.GetTransactionByBlockNumberAndIndexRequest")
	proto.RegisterType((*SubscribeTransactionsRequest)(nil), "exowei.ethereum.v1alpha1.SubscribeTransactionsRequest")
	proto.RegisterType((*GetTransactionReceiptRequest)(nil), "exowei.ethereum.v1alpha1.GetTransactionReceiptRequest")
	proto.RegisterType((*PendingTransactionsRequest)(nil), "exowei.ethereum.v1alpha1.PendingTransactionsRequest")
	proto.RegisterType((*PendingTransactionsResponse)(nil), "exowei.ethereum.v1alpha1.PendingTransactionsResponse")
	proto.RegisterType((*GetUncleByBlockHashAndIndexRequest)(nil), "exowei.ethereum.v1alpha1.GetUncleByBlockHashAndIndexRequest")
	proto.RegisterType((*GetUncleByBlockNumberAndIndexRequest)(nil), "exowei.ethereum.v1alpha1.GetUncleByBlockNumberAndIndexRequest")
}

func init() { proto.RegisterFile("ethereum/v1alpha1/ethereum.proto", fileDescriptor_3d228465d76da121) }

var fileDescriptor_3d228465d76da121 = []byte{
	// 2162 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0xdd, 0x6f, 0xdb, 0xd6,
	0x15, 0x17, 0x2d, 0x7f, 0x48, 0x47, 0xb2, 0x2d, 0x5f, 0xbb, 0x09, 0xa3, 0xc4, 0x1f, 0x65, 0x96,
	0xce, 0x71, 0x1a, 0xbb, 0x76, 0xda, 0x22, 0xcd, 0x8a, 0xb5, 0xb6, 0xe3, 0xa8, 0x19, 0x8c, 0xcd,
	0xa0, 0xe3, 0x16, 0x1b, 0x30, 0x68, 0x34, 0x75, 0x4d, 0xb1, 0xa5, 0x48, 0x8d, 0xf7, 0xd2, 0x71,
	0xb2, 0x61, 0x1f, 0xc5, 0xfe, 0x80, 0x0d, 0xdb, 0xcb, 0x80, 0xbd, 0x0e, 0x18, 0xb0, 0xff, 0x61,
	0xcf, 0xdd, 0xdb, 0xfe, 0x84, 0x25, 0x7f, 0xc1, 0x80, 0xbd, 0xec, 0x71, 0xb8, 0x1f, 0xa4, 0x48,
	0x4a, 0xa2, 0x28, 0x35, 0x4f, 0xe1, 0x3d, 0xf7, 0x7c, 0xdd, 0x73, 0xcf, 0x3d, 0xe7, 0xfc, 0xe4,
	0xc0, 0x06, 0xa6, 0x6d, 0xec, 0xe3, 0xa0, 0xb3, 0x73, 0xb9, 0x6b, 0x38, 0xdd, 0xb6, 0xb1, 0xbb,
	0x13, 0x52, 0xb6, 0xbb, 0xbe, 0x47, 0x3d, 0xa4, 0xe2, 0x2b, 0xef, 0x39, 0xb6, 0xb7, 0x23, 0x72,
	0xc8, 0x58, 0x5f, 0xb1, 0x3c, 0xcb, 0xe3, 0x4c, 0x3b, 0xec, 0x4b, 0xf0, 0xd7, 0xd7, 0x2d, 0xcf,
	0xb3, 0x1c, 0xbc, 0xc3, 0x57, 0xe7, 0xc1, 0xc5, 0x0e, 0xb5, 0x3b, 0x98, 0x50, 0xa3, 0xd3, 0x15,
	0x0c, 0xda, 0x3d, 0x98, 0x39, 0x62, 0xba, 0x50, 0x0d, 0x8a, 0xcf, 0xb1, 0xad, 0x2a, 0x1b, 0xca,
	0xe6, 0xb4, 0xce, 0x3e, 0x19, 0x05, 0xd3, 0xb6, 0x3a, 0x25, 0x28, 0x98, 0xb6, 0xb5, 0x3f, 0x14,
	0xa1, 0xf2, 0xcc, 0x37, 0x5c, 0x62, 0x98, 0xd4, 0xf6, 0x5c, 0x84, 0x60, 0xba, 0x6d, 0x90, 0x36,
	0x17, 0x2a, 0xeb, 0xfc, 0x9b, 0xd1, 0x2e, 0x7c, 0xaf, 0xc3, 0xc5, 0xca, 0x3a, 0xff, 0x46, 0x0b,
	0x30, 0x45, 0x3d, 0xb5, 0xc8, 0x29, 0x53, 0xd4, 0x43, 0x2b, 0x30, 0x63, 0xbb, 0xdd, 0x80, 0xaa,
	0xd3, 0x1b, 0xca, 0x66, 0x55, 0x17, 0x0b, 0x46, 0x75, 0x3d, 0xd7, 0xc4, 0xea, 0x0c, 0xb7, 0x28,
	0x16, 0xcc, 0x0b, 0xcb, 0x20, 0xea, 0xec, 0x86, 0xb2, 0x39, 0xaf, 0xb3, 0x4f, 0xf4, 0x31, 0x94,
	0x2d, 0x83, 0x34, 0xbb, 0xbe, 0x6d, 0x62, 0x75, 0x6e, 0x43, 0xd9, 0xac, 0xec, 0xad, 0x6f, 0x0f,
	0x8b, 0xcb, 0x36, 0x3f, 0x9d, 0x5e, 0xb2, 0x0c, 0x72, 0xc2, 0x04, 0xd0, 0x07, 0x30, 0x73, 0x69,
	0x38, 0x01, 0x56, 0x4b, 0xf9, 0x24, 0x05, 0x37, 0x5a, 0x05, 0x38, 0x77, 0x3c, 0xf3, 0xab, 0x26,
	0x3f, 0x70, 0x99, 0x1f, 0xa5, 0xcc, 0x29, 0x9f, 0xb1, 0x53, 0xbf, 0x0d, 0x55, 0xb1, 0xed, 0x06,
	0x9d, 0x73, 0xec, 0xab, 0xc0, 0xdd, 0xad, 0x70, 0xda, 0x0f, 0x39, 0x09, 0xdd, 0x83, 0x25, 0xda,
	0x8b, 0x5d, 0xd3, 0x76, 0x5b, 0xf8, 0x4a, 0xad, 0x70, 0xbe, 0x5a, 0x6c, 0xe3, 0x29, 0xa3, 0xa3,
	0x2a, 0x28, 0x97, 0x6a, 0x95, 0x47, 0x47, 0xb9, 0x64, 0x2b, 0x5f, 0x9d, 0x17, 0x2b, 0x9f, 0xad,
	0x88, 0xba, 0x20, 0x56, 0x44, 0xfb, 0x7a, 0x0a, 0x8a, 0xc7, 0x9e, 0x85, 0x6e, 0x42, 0xd9, 0xf1,
	0x2c, 0xa9, 0x56, 0xdc, 0x62, 0xc9, 0xf1, 0x2c, 0xa1, 0x2e, 0xed, 0xde, 0x54, 0xbf, 0x7b, 0xc9,
	0x03, 0x16, 0xd3, 0x07, 0xbc, 0x0b, 0x71, 0x27, 0x05, 0xd3, 0x34, 0x67, 0x5a, 0x8c, 0xd1, 0x39,
	0xeb, 0xc0, 0x83, 0xce, 0x0c, 0x39, 0xa8, 0x0a, 0x73, 0x46, 0xab, 0xe5, 0x63, 0x22, 0xae, 0xb8,
	0xac, 0x87, 0x4b, 0x96, 0x48, 0x2d, 0x83, 0x1a, 0xfc, 0x86, 0xab, 0x3a, 0xff, 0x46, 0xd7, 0x60,
	0x96, 0x7a, 0x5d, 0xdb, 0x24, 0x6a, 0x69, 0xa3, 0xb8, 0x59, 0xd6, 0xe5, 0x4a, 0xfb, 0x6f, 0x11,
	0x50, 0x2c, 0x31, 0x75, 0x6c, 0x62, 0xbb, 0x4b, 0x07, 0x3a, 0xad, 0x8c, 0xe1, 0xf4, 0xd4, 0x10,
	0xa7, 0x47, 0xc4, 0x2a, 0x1d, 0xed, 0xe9, 0xfe, 0x68, 0x87, 0xaf, 0x64, 0xa6, 0xef, 0x95, 0xcc,
	0x46, 0xaf, 0x64, 0x1b, 0x96, 0xcd, 0xa0, 0x13, 0x38, 0x06, 0xb5, 0x2f, 0x71, 0x93, 0xa5, 0x7c,
	0x40, 0x70, 0x8b, 0xc7, 0x63, 0x5e, 0x5f, 0xea, 0x6d, 0x35, 0x0c, 0x72, 0x46, 0x70, 0x0b, 0xdd,
	0x80, 0x52, 0xc4, 0x54, 0xe2, 0x4c, 0x73, 0x96, 0xdc, 0xba, 0x0b, 0x35, 0xd3, 0x73, 0xa9, 0x6f,
	0x98, 0xb4, 0x19, 0x86, 0x5b, 0xe4, 0xf0, 0x62, 0x48, 0xdf, 0x97, 0x61, 0xdf, 0x85, 0x69, 0xc7,
	0xb3, 0x88, 0x0a, 0x1b, 0xc5, 0xcd, 0xca, 0xde, 0xea, 0xf0, 0xe7, 0x71, 0xec, 0x59, 0x3a, 0x67,
	0x65, 0xe1, 0x60, 0xff, 0x36, 0xcf, 0x1d, 0xcf, 0xeb, 0xf0, 0x94, 0x2e, 0xeb, 0x2c, 0x19, 0xc9,
	0x01, 0x23, 0xb0, 0xb3, 0xfa, 0x9e, 0x47, 0x79, 0x3a, 0x97, 0x75, 0xfe, 0x8d, 0x0e, 0x61, 0x96,
	0x50, 0x83, 0x06, 0x84, 0xa7, 0xf5, 0xc2, 0xde, 0xbd, 0xe1, 0x76, 0x62, 0xf7, 0x7a, 0xca, 0x45,
	0x74, 0x29, 0xaa, 0xfd, 0x63, 0x06, 0x66, 0x0e, 0x58, 0x50, 0x59, 0x5e, 0xc8, 0x58, 0x2b, 0xfc,
	0xe0, 0x72, 0x15, 0x15, 0xa8, 0xa9, 0x58, 0x81, 0x5a, 0x87, 0x4a, 0xd7, 0xf0, 0xb1, 0x4b, 0xe3,
	0xb7, 0x07, 0x82, 0xc4, 0xaf, 0x2f, 0xaa, 0x43, 0x22, 0xbf, 0x65, 0x1d, 0x5a, 0x87, 0x0a, 0x69,
	0x1b, 0x0f, 0x9a, 0x81, 0x6b, 0x3a, 0x98, 0xc8, 0x8b, 0x03, 0x46, 0x3a, 0xe3, 0x94, 0x54, 0x14,
	0x66, 0xd3, 0x51, 0x48, 0x26, 0x18, 0x69, 0xf2, 0x90, 0xcc, 0x71, 0xae, 0x78, 0x82, 0x11, 0x9d,
	0x85, 0x67, 0x15, 0x80, 0x9d, 0x11, 0x0b, 0xae, 0x92, 0xd0, 0xc5, 0x29, 0x7c, 0xfb, 0x36, 0xcc,
	0xfb, 0x22, 0xc5, 0xa5, 0x1e, 0x71, 0x97, 0xd5, 0x90, 0xc8, 0x99, 0x56, 0x60, 0xa6, 0x63, 0xbb,
	0xb2, 0x16, 0x95, 0x75, 0xb1, 0x40, 0x6b, 0x00, 0x2d, 0xfb, 0xe2, 0xc2, 0x36, 0x03, 0x87, 0xbe,
	0x90, 0x77, 0x15, 0xa3, 0xf0, 0x27, 0xe3, 0x51, 0xc3, 0x69, 0xc6, 0xb8, 0xaa, 0xf2, 0xc9, 0x30,
	0xfa, 0xe3, 0x1e, 0xeb, 0x2a, 0x00, 0xbe, 0xa2, 0xbe, 0xd1, 0xe4, 0xcf, 0x54, 0x94, 0xa7, 0x32,
	0xa7, 0x3c, 0x66, 0x6f, 0x35, 0x7a, 0x24, 0xc4, 0x7e, 0x89, 0x79, 0xbd, 0x9a, 0x97, 0x8f, 0xe4,
	0xd4, 0x7e, 0x89, 0x59, 0xbd, 0x62, 0xd9, 0xea, 0xd8, 0x1d, 0x9b, 0xaa, 0x8b, 0x7c, 0x97, 0xa5,
	0xef, 0x31, 0x5b, 0x27, 0x52, 0xb9, 0x96, 0x4c, 0xe5, 0x87, 0x50, 0x8e, 0x7a, 0x98, 0xba, 0xc4,
	0x6b, 0x78, 0x7d, 0x5b, 0x74, 0xb9, 0xed, 0xb0, 0xcb, 0x6d, 0x3f, 0x0b, 0x39, 0xf4, 0x1e, 0x33,
	0x7a, 0x0a, 0xd5, 0x78, 0xa0, 0x55, 0xc4, 0x33, 0xfc, 0x4e, 0xae, 0xcc, 0xd3, 0x13, 0xa2, 0xe8,
	0x3e, 0xa0, 0x74, 0x61, 0xc1, 0x44, 0x5d, 0xe6, 0x35, 0x69, 0x29, 0x55, 0x5a, 0x30, 0x61, 0xe9,
	0x29, 0xd3, 0x66, 0x45, 0x94, 0x2d, 0xb1, 0xd2, 0x54, 0xb8, 0x76, 0xc2, 0x5c, 0x36, 0x3d, 0xe7,
	0x73, 0xec, 0x13, 0x5e, 0xb9, 0x7e, 0x1e, 0x60, 0x42, 0xb5, 0xc7, 0x70, 0xbd, 0x6f, 0x87, 0x74,
	0x3d, 0x97, 0x60, 0x76, 0x43, 0x5d, 0xb9, 0xd5, 0xbc, 0x14, 0x7b, 0x32, 0xeb, 0x17, 0xbb, 0x49,
	0x11, 0xad, 0x06, 0x0b, 0xa7, 0x2f, 0x5c, 0xd3, 0x76, 0xad, 0x50, 0xef, 0x5f, 0x14, 0x58, 0x8c,
	0x48, 0x52, 0xa1, 0x0a, 0x73, 0x44, 0x90, 0xb8, 0x9e, 0x92, 0x1e, 0x2e, 0xd1, 0x1d, 0x58, 0x20,
	0xd4, 0xf0, 0xa9, 0xed, 0x5a, 0x4d, 0x7e, 0x73, 0xb2, 0x22, 0xce, 0x87, 0x54, 0xf1, 0xfa, 0x6e,
	0xc3, 0xbc, 0x19, 0xf8, 0xfc, 0x49, 0x09, 0xae, 0x22, 0xe7, 0xaa, 0x4a, 0x62, 0xc4, 0xd4, 0xb6,
	0xad, 0x36, 0x26, 0x21, 0x93, 0xa8, 0x8a, 0x55, 0x49, 0xe4, 0x4c, 0xda, 0x12, 0x2c, 0x36, 0x64,
	0xa3, 0x0e, 0x3d, 0x3e, 0x81, 0x5a, 0x8f, 0x24, 0x3d, 0x4e, 0x4c, 0x00, 0xca, 0x98, 0x13, 0x80,
	0xb6, 0x02, 0xe8, 0xa0, 0x57, 0x8a, 0x43, 0x3b, 0x0f, 0x61, 0x39, 0x41, 0x95, 0xa6, 0xd2, 0xb5,
	0x5c, 0xe9, 0xab, 0xe5, 0xda, 0x09, 0x2c, 0x35, 0x30, 0x3d, 0x30, 0x1c, 0xc3, 0x8d, 0xdc, 0x8e,
	0xf7, 0x35, 0x25, 0xd9, 0xd7, 0x46, 0xf7, 0x62, 0xed, 0x47, 0x80, 0xe2, 0x1a, 0xa5, 0x2b, 0x1f,
	0xc1, 0xdc, 0xb9, 0x20, 0xe5, 0x3d, 0x73, 0xc8, 0xaf, 0x7d, 0x09, 0xcb, 0x0d, 0x4c, 0x4f, 0xa9,
	0xe7, 0x1b, 0x16, 0xde, 0xa7, 0xa3, 0x9d, 0xbc, 0x06, 0xb3, 0xde, 0xc5, 0x05, 0xc1, 0x54, 0x8e,
	0x7f, 0x72, 0xd5, 0xe7, 0x7c, 0xb1, 0xdf, 0xf9, 0x2d, 0x58, 0x49, 0xda, 0x92, 0xee, 0x87, 0xfd,
	0x5c, 0xe9, 0xf5, 0x73, 0xed, 0xc7, 0x50, 0x6f, 0x60, 0x1a, 0x7b, 0x67, 0x87, 0x5e, 0xe0, 0xd2,
	0x37, 0x12, 0xc3, 0x1f, 0xc0, 0xcd, 0x81, 0xaa, 0xa5, 0x37, 0xa9, 0x7e, 0x6f, 0xb2, 0x4d, 0x79,
	0xb9, 0xf1, 0x72, 0xcc, 0x85, 0xb4, 0x27, 0x70, 0x87, 0xdd, 0x07, 0xd3, 0x9e, 0x56, 0x78, 0xf0,
	0x82, 0xbd, 0xf1, 0xd0, 0xe3, 0xe4, 0x60, 0xa0, 0xa4, 0x06, 0x03, 0xed, 0x0c, 0xde, 0x19, 0xa5,
	0x67, 0x12, 0xf7, 0x8e, 0xe1, 0xbb, 0xc3, 0xd5, 0x26, 0xb2, 0x3c, 0x4f, 0x3a, 0x7f, 0x01, 0x9b,
	0xa3, 0xb5, 0x4d, 0xe2, 0xe6, 0xa7, 0xb0, 0xde, 0xc0, 0x94, 0x77, 0x4b, 0xa9, 0xed, 0x20, 0x8c,
	0x4c, 0xce, 0xf8, 0x1d, 0xc2, 0xc6, 0x70, 0x0d, 0xd2, 0xa5, 0x75, 0xa8, 0xf0, 0xea, 0x9a, 0x70,
	0x06, 0x82, 0x48, 0x46, 0x7b, 0x02, 0x6f, 0x0f, 0x52, 0x32, 0x76, 0x9c, 0x8e, 0x40, 0xcb, 0xd2,
	0x93, 0xd7, 0x9d, 0x2d, 0x58, 0x68, 0x60, 0x7a, 0xe8, 0xb5, 0x46, 0x97, 0x0e, 0xed, 0x0e, 0x2c,
	0x46, 0xbc, 0x19, 0xaf, 0x6a, 0x07, 0x6e, 0x9c, 0x62, 0xb7, 0xa5, 0x1b, 0xcf, 0x13, 0x33, 0xb1,
	0xd0, 0x3e, 0x48, 0xa0, 0x01, 0xf5, 0x41, 0x02, 0xbd, 0x86, 0x93, 0x73, 0x8a, 0xd6, 0x3e, 0x87,
	0xca, 0xa1, 0xe1, 0x38, 0xa1, 0xad, 0x06, 0x54, 0x62, 0x1c, 0xb2, 0x6a, 0xe5, 0x6c, 0xb8, 0x71,
	0x49, 0x4d, 0x83, 0xaa, 0xd0, 0x9b, 0x71, 0xea, 0x9f, 0x02, 0x3a, 0x22, 0xd4, 0xee, 0x18, 0x94,
	0x4d, 0xc4, 0x6f, 0xdc, 0x85, 0x47, 0xb0, 0x9c, 0x50, 0x2f, 0x3d, 0xb9, 0x0d, 0xf3, 0x58, 0x92,
	0x5b, 0x6c, 0x46, 0x97, 0x37, 0x5c, 0x8d, 0x88, 0x0d, 0x83, 0x68, 0x3e, 0xbc, 0x15, 0x3e, 0xa9,
	0x71, 0xea, 0x05, 0x7a, 0x04, 0x37, 0x6c, 0xd7, 0x74, 0x82, 0x16, 0x6e, 0x5e, 0x04, 0x8e, 0xd3,
	0x4c, 0x8c, 0x2f, 0x53, 0xbc, 0x57, 0x5f, 0x97, 0x0c, 0x4f, 0x02, 0xc7, 0x89, 0xf9, 0x4e, 0xb4,
	0x2b, 0xb8, 0xde, 0xb3, 0x39, 0x6e, 0x72, 0x67, 0x5b, 0x2e, 0x66, 0x5b, 0xf6, 0xe0, 0xfa, 0xb1,
	0x4d, 0xe2, 0xa5, 0x97, 0xc4, 0x53, 0xdb, 0xec, 0xbd, 0x04, 0x96, 0xda, 0x62, 0xc9, 0xc6, 0xc1,
	0xae, 0x61, 0x61, 0x31, 0x2c, 0x8a, 0x72, 0x5e, 0x62, 0x04, 0x3e, 0x2b, 0xae, 0x02, 0xf0, 0x4d,
	0xea, 0x7d, 0x85, 0xdd, 0x10, 0x6f, 0x31, 0xca, 0x33, 0x46, 0xd0, 0x30, 0xa8, 0xfd, 0x06, 0xe5,
	0xfd, 0xa4, 0x87, 0x3e, 0x65, 0xe2, 0xa1, 0x4f, 0xfb, 0x2c, 0xdd, 0x51, 0x92, 0x77, 0x39, 0xc6,
	0x33, 0xb9, 0xe4, 0x25, 0x36, 0xa1, 0x29, 0x2a, 0x64, 0xfb, 0x6e, 0x8b, 0x83, 0xcc, 0x9c, 0x29,
	0x32, 0x0e, 0x6e, 0xd5, 0x7e, 0x09, 0x5b, 0x03, 0xed, 0x8a, 0x4b, 0x4f, 0x5b, 0xce, 0x91, 0x26,
	0x63, 0x59, 0x7f, 0x08, 0xb7, 0x4e, 0x83, 0x73, 0x62, 0xfa, 0xf6, 0x39, 0x1e, 0x2b, 0x39, 0xb4,
	0xa7, 0x70, 0x2b, 0xe9, 0xb7, 0x04, 0xf8, 0x13, 0x84, 0xfe, 0x16, 0xd4, 0x4f, 0xb0, 0xdb, 0xb2,
	0x5d, 0x6b, 0x80, 0x0b, 0x5a, 0x1b, 0x6e, 0x0e, 0xdc, 0x7d, 0xf3, 0xc9, 0xd4, 0xea, 0x75, 0x8f,
	0xc9, 0x2f, 0x3f, 0x6a, 0x2e, 0xf1, 0xc0, 0x8b, 0xe6, 0x22, 0x42, 0xfe, 0x25, 0x7c, 0x27, 0x65,
	0x65, 0xe2, 0xab, 0x1e, 0x65, 0x6b, 0xeb, 0x3e, 0x2c, 0xf5, 0x41, 0x75, 0x54, 0x81, 0xb9, 0x27,
	0xfb, 0x4f, 0x8f, 0xcf, 0xf4, 0xa3, 0x5a, 0x81, 0x2d, 0x4e, 0xcf, 0x0e, 0x0f, 0x8f, 0x4e, 0x4f,
	0x6b, 0xca, 0xde, 0x3f, 0x6f, 0x40, 0xe9, 0x48, 0x06, 0x0c, 0x5d, 0xc1, 0x62, 0x0a, 0xee, 0xa0,
	0xf7, 0x86, 0x47, 0x75, 0x30, 0x66, 0xaa, 0xef, 0x8e, 0x21, 0x21, 0x2e, 0x54, 0x2b, 0xa0, 0x9f,
	0xc1, 0x9c, 0xc4, 0x43, 0x68, 0x73, 0xb8, 0x7c, 0x12, 0x45, 0xd5, 0xef, 0xe6, 0xe0, 0x8c, 0x2c,
	0x98, 0x50, 0x0a, 0x01, 0x0c, 0xca, 0x10, 0x4c, 0xe1, 0x9e, 0xfa, 0x56, 0x1e, 0xd6, 0xc8, 0x88,
	0x03, 0x95, 0xd8, 0xf5, 0xa2, 0x77, 0x87, 0x0b, 0xf7, 0x0f, 0x3b, 0xf5, 0xfb, 0x39, 0xb9, 0x23,
	0x6b, 0x36, 0x40, 0x0f, 0x9f, 0xa0, 0x8c, 0xdf, 0x6e, 0xfa, 0x70, 0x51, 0xfd, 0xdd, 0x7c, 0xcc,
	0x91, 0x29, 0x0f, 0xaa, 0x71, 0x34, 0x81, 0xee, 0x67, 0xca, 0xa7, 0x11, 0x4e, 0x7d, 0x3b, 0x2f,
	0x7b, 0x64, 0xf0, 0x77, 0x0a, 0xc7, 0x4a, 0xe9, 0xd1, 0x17, 0xbd, 0x9f, 0xa9, 0x69, 0x08, 0x84,
	0xa9, 0x7f, 0x30, 0xa6, 0x54, 0xe4, 0xc6, 0x5f, 0x15, 0x58, 0xcb, 0xc6, 0x0a, 0xe8, 0x93, 0xec,
	0x50, 0x8e, 0x44, 0x2b, 0xf5, 0x4f, 0x27, 0x57, 0x10, 0xf9, 0xf9, 0x77, 0x85, 0xcf, 0xe4, 0x99,
	0x70, 0x01, 0xed, 0x4f, 0x62, 0x28, 0x99, 0xa3, 0x07, 0xdf, 0x46, 0x45, 0xe4, 0xed, 0x1f, 0x15,
	0x50, 0x87, 0x21, 0x08, 0xf4, 0x51, 0xa6, 0x89, 0x2c, 0xdc, 0x52, 0x7f, 0x34, 0x89, 0x68, 0xe4,
	0xd5, 0x9f, 0x15, 0x0e, 0x83, 0x87, 0x40, 0x09, 0xf4, 0xbd, 0xf1, 0x94, 0x27, 0xe3, 0xf6, 0xf1,
	0x64, 0xc2, 0xf1, 0xfa, 0x28, 0x21, 0x47, 0x56, 0x7d, 0x4c, 0x22, 0x98, 0xac, 0xfa, 0x98, 0xc2,
	0x2f, 0x5a, 0x01, 0xfd, 0x56, 0x01, 0xd4, 0x8f, 0x3e, 0xd0, 0x83, 0x8c, 0x1a, 0x3b, 0x0c, 0xdc,
	0xd4, 0xdf, 0x1f, 0x4f, 0x28, 0xf2, 0xe1, 0x0b, 0x98, 0x66, 0xf8, 0x02, 0x65, 0xb4, 0xf2, 0x18,
	0xae, 0xa9, 0xbf, 0x33, 0x8a, 0x2d, 0x5e, 0x97, 0x63, 0xa8, 0x21, 0xab, 0x2e, 0xf7, 0x63, 0x97,
	0xac, 0xba, 0x3c, 0x00, 0x8a, 0x68, 0x05, 0xd4, 0xe2, 0x58, 0x32, 0x86, 0x33, 0xd0, 0xce, 0xe8,
	0x67, 0x93, 0xac, 0x09, 0xeb, 0x23, 0x7a, 0x81, 0x56, 0x40, 0x6d, 0xa8, 0xa5, 0x91, 0x05, 0xda,
	0xcd, 0x63, 0x27, 0x99, 0x99, 0x39, 0x2c, 0xfd, 0x02, 0x6a, 0xe9, 0xc1, 0x3e, 0xcb, 0xd2, 0x10,
	0xd4, 0x51, 0xdf, 0x1b, 0x47, 0x24, 0x0a, 0xe6, 0x25, 0xff, 0x1d, 0xab, 0x6f, 0xdc, 0x47, 0xb9,
	0x4b, 0x7a, 0x32, 0xb0, 0xf9, 0xa6, 0x44, 0xad, 0x80, 0x7e, 0xaf, 0xf0, 0x1f, 0x28, 0xb2, 0xd1,
	0x01, 0x3a, 0xc8, 0xef, 0xc5, 0xb0, 0xe9, 0x32, 0xbf, 0x4b, 0x7f, 0x52, 0xe0, 0x76, 0x0e, 0xe0,
	0x80, 0x1e, 0x8f, 0xe9, 0xd4, 0xc0, 0x61, 0x34, 0xbf, 0x5b, 0x2f, 0xe1, 0xad, 0x81, 0x80, 0x02,
	0x7d, 0x98, 0x51, 0x06, 0x32, 0x10, 0x48, 0x6e, 0xcb, 0xef, 0x29, 0xe8, 0xd7, 0x1c, 0xd2, 0x0f,
	0xf8, 0x9b, 0xe3, 0x87, 0x79, 0x63, 0x90, 0xc4, 0x30, 0x59, 0x83, 0x51, 0xbf, 0x90, 0x9c, 0x53,
	0x06, 0x60, 0x95, 0xac, 0x39, 0x65, 0x38, 0xf0, 0xc9, 0x9a, 0x53, 0x32, 0x00, 0x91, 0x56, 0x40,
	0xbf, 0xe2, 0xa0, 0x78, 0x18, 0x8e, 0x41, 0x39, 0xda, 0x4f, 0x46, 0x82, 0xe6, 0x28, 0x11, 0x5f,
	0x2b, 0xb0, 0x9a, 0x09, 0x71, 0xd0, 0xf7, 0x73, 0xbb, 0x30, 0x38, 0x1d, 0x47, 0x3b, 0x71, 0xf0,
	0xc9, 0x37, 0xaf, 0xd6, 0x0a, 0xff, 0x79, 0xb5, 0x56, 0xf8, 0xdb, 0xeb, 0xb5, 0xc2, 0x37, 0xaf,
	0xd7, 0x94, 0x7f, 0xbd, 0x5e, 0x53, 0xfe, 0xfd, 0x7a, 0x4d, 0xf9, 0xc9, 0xba, 0x94, 0xb5, 0xbd,
	0x1d, 0xa3, 0x6b, 0xef, 0xf4, 0xfd, 0xff, 0x8e, 0xdf, 0x28, 0xca, 0xff, 0x14, 0xe5, 0x7c, 0x96,
	0xff, 0xe5, 0xe6, 0xc1, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x92, 0x76, 0x11, 0xcd, 0x01, 0x22,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EthereumClient is the client API for Ethereum service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EthereumClient interface {
	ProtocolVersion(ctx context.Context, in *ProtocolVersionRequest, opts ...grpc.CallOption) (*ProtocolVersionResponse, error)
	Syncing(ctx context.Context, in *SyncingRequest, opts ...grpc.CallOption) (*SyncingResponse, error)
	GasPrice(ctx context.Context, in *GasPriceRequest, opts ...grpc.CallOption) (*GasPriceResponse, error)
	BlockNumber(ctx context.Context, in *BlockNumberRequest, opts ...grpc.CallOption) (*BlockNumberResponse, error)
	GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error)
	GetStorageAt(ctx context.Context, in *GetStorageAtRequest, opts ...grpc.CallOption) (*GetStorageAtResponse, error)
	GetTransactionCount(ctx context.Context, in *GetTransactionCountRequest, opts ...grpc.CallOption) (*GetTransactionCountResponse, error)
	GetBlockTransactionCountByHash(ctx context.Context, in *GetBlockTransactionCountByHashRequest, opts ...grpc.CallOption) (*GetBlockTransactionCountByHashResponse, error)
	GetBlockTransactionCountByNumber(ctx context.Context, in *GetBlockTransactionCountByNumberRequest, opts ...grpc.CallOption) (*GetBlockTransactionCountByNumberResponse, error)
	GetUncleCountByBlockHash(ctx context.Context, in *GetUncleCountByBlockHashRequest, opts ...grpc.CallOption) (*GetUncleCountByBlockHashResponse, error)
	GetUncleCountByBlockNumber(ctx context.Context, in *GetUncleCountByBlockNumberRequest, opts ...grpc.CallOption) (*GetUncleCountByBlockNumberResponse, error)
	GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error)
	SendRawTransaction(ctx context.Context, in *SendRawTransactionRequest, opts ...grpc.CallOption) (*SendRawTransactionResponse, error)
	Call(ctx context.Context, in *CallRequest, opts ...grpc.CallOption) (*CallResponse, error)
	EstimateGas(ctx context.Context, in *EstimateGasRequest, opts ...grpc.CallOption) (*EstimateGasResponse, error)
	GetBlockByHash(ctx context.Context, in *GetBlockByHashRequest, opts ...grpc.CallOption) (*Block, error)
	GetBlockByNumber(ctx context.Context, in *GetBlockByNumberRequest, opts ...grpc.CallOption) (*Block, error)
	ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*ListTransactionsResponse, error)
	GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*Transaction, error)
	GetTransactionByBlockHashAndIndex(ctx context.Context, in *GetTransactionByBlockHashAndIndexRequest, opts ...grpc.CallOption) (*Transaction, error)
	GetTransactionByBlockNumberAndIndex(ctx context.Context, in *GetTransactionByBlockNumberAndIndexRequest, opts ...grpc.CallOption) (*Transaction, error)
	SubscribeTransactions(ctx context.Context, in *SubscribeTransactionsRequest, opts ...grpc.CallOption) (Ethereum_SubscribeTransactionsClient, error)
	GetTransactionReceipt(ctx context.Context, in *GetTransactionReceiptRequest, opts ...grpc.CallOption) (*TransactionReceipt, error)
	PendingTransactions(ctx context.Context, in *PendingTransactionsRequest, opts ...grpc.CallOption) (*PendingTransactionsResponse, error)
	GetUncleByBlockHashAndIndex(ctx context.Context, in *GetUncleByBlockHashAndIndexRequest, opts ...grpc.CallOption) (*Block, error)
	GetUncleByBlockNumberAndIndex(ctx context.Context, in *GetUncleByBlockNumberAndIndexRequest, opts ...grpc.CallOption) (*Block, error)
}

type ethereumClient struct {
	cc *grpc.ClientConn
}

func NewEthereumClient(cc *grpc.ClientConn) EthereumClient {
	return &ethereumClient{cc}
}

func (c *ethereumClient) ProtocolVersion(ctx context.Context, in *ProtocolVersionRequest, opts ...grpc.CallOption) (*ProtocolVersionResponse, error) {
	out := new(ProtocolVersionResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/ProtocolVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) Syncing(ctx context.Context, in *SyncingRequest, opts ...grpc.CallOption) (*SyncingResponse, error) {
	out := new(SyncingResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/Syncing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GasPrice(ctx context.Context, in *GasPriceRequest, opts ...grpc.CallOption) (*GasPriceResponse, error) {
	out := new(GasPriceResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GasPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) BlockNumber(ctx context.Context, in *BlockNumberRequest, opts ...grpc.CallOption) (*BlockNumberResponse, error) {
	out := new(BlockNumberResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/BlockNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetBalance(ctx context.Context, in *GetBalanceRequest, opts ...grpc.CallOption) (*GetBalanceResponse, error) {
	out := new(GetBalanceResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetStorageAt(ctx context.Context, in *GetStorageAtRequest, opts ...grpc.CallOption) (*GetStorageAtResponse, error) {
	out := new(GetStorageAtResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetStorageAt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetTransactionCount(ctx context.Context, in *GetTransactionCountRequest, opts ...grpc.CallOption) (*GetTransactionCountResponse, error) {
	out := new(GetTransactionCountResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetBlockTransactionCountByHash(ctx context.Context, in *GetBlockTransactionCountByHashRequest, opts ...grpc.CallOption) (*GetBlockTransactionCountByHashResponse, error) {
	out := new(GetBlockTransactionCountByHashResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetBlockTransactionCountByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetBlockTransactionCountByNumber(ctx context.Context, in *GetBlockTransactionCountByNumberRequest, opts ...grpc.CallOption) (*GetBlockTransactionCountByNumberResponse, error) {
	out := new(GetBlockTransactionCountByNumberResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetBlockTransactionCountByNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetUncleCountByBlockHash(ctx context.Context, in *GetUncleCountByBlockHashRequest, opts ...grpc.CallOption) (*GetUncleCountByBlockHashResponse, error) {
	out := new(GetUncleCountByBlockHashResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetUncleCountByBlockHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetUncleCountByBlockNumber(ctx context.Context, in *GetUncleCountByBlockNumberRequest, opts ...grpc.CallOption) (*GetUncleCountByBlockNumberResponse, error) {
	out := new(GetUncleCountByBlockNumberResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetUncleCountByBlockNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetCode(ctx context.Context, in *GetCodeRequest, opts ...grpc.CallOption) (*GetCodeResponse, error) {
	out := new(GetCodeResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) SendRawTransaction(ctx context.Context, in *SendRawTransactionRequest, opts ...grpc.CallOption) (*SendRawTransactionResponse, error) {
	out := new(SendRawTransactionResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/SendRawTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) Call(ctx context.Context, in *CallRequest, opts ...grpc.CallOption) (*CallResponse, error) {
	out := new(CallResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/Call", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) EstimateGas(ctx context.Context, in *EstimateGasRequest, opts ...grpc.CallOption) (*EstimateGasResponse, error) {
	out := new(EstimateGasResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/EstimateGas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetBlockByHash(ctx context.Context, in *GetBlockByHashRequest, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetBlockByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetBlockByNumber(ctx context.Context, in *GetBlockByNumberRequest, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetBlockByNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) ListTransactions(ctx context.Context, in *ListTransactionsRequest, opts ...grpc.CallOption) (*ListTransactionsResponse, error) {
	out := new(ListTransactionsResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/ListTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetTransactionByHash(ctx context.Context, in *GetTransactionByHashRequest, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetTransactionByBlockHashAndIndex(ctx context.Context, in *GetTransactionByBlockHashAndIndexRequest, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionByBlockHashAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetTransactionByBlockNumberAndIndex(ctx context.Context, in *GetTransactionByBlockNumberAndIndexRequest, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionByBlockNumberAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) SubscribeTransactions(ctx context.Context, in *SubscribeTransactionsRequest, opts ...grpc.CallOption) (Ethereum_SubscribeTransactionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Ethereum_serviceDesc.Streams[0], "/exowei.ethereum.v1alpha1.Ethereum/SubscribeTransactions", opts...)
	if err != nil {
		return nil, err
	}
	x := &ethereumSubscribeTransactionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Ethereum_SubscribeTransactionsClient interface {
	Recv() (*Transaction, error)
	grpc.ClientStream
}

type ethereumSubscribeTransactionsClient struct {
	grpc.ClientStream
}

func (x *ethereumSubscribeTransactionsClient) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ethereumClient) GetTransactionReceipt(ctx context.Context, in *GetTransactionReceiptRequest, opts ...grpc.CallOption) (*TransactionReceipt, error) {
	out := new(TransactionReceipt)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionReceipt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) PendingTransactions(ctx context.Context, in *PendingTransactionsRequest, opts ...grpc.CallOption) (*PendingTransactionsResponse, error) {
	out := new(PendingTransactionsResponse)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/PendingTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetUncleByBlockHashAndIndex(ctx context.Context, in *GetUncleByBlockHashAndIndexRequest, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetUncleByBlockHashAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethereumClient) GetUncleByBlockNumberAndIndex(ctx context.Context, in *GetUncleByBlockNumberAndIndexRequest, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/exowei.ethereum.v1alpha1.Ethereum/GetUncleByBlockNumberAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EthereumServer is the server API for Ethereum service.
type EthereumServer interface {
	ProtocolVersion(context.Context, *ProtocolVersionRequest) (*ProtocolVersionResponse, error)
	Syncing(context.Context, *SyncingRequest) (*SyncingResponse, error)
	GasPrice(context.Context, *GasPriceRequest) (*GasPriceResponse, error)
	BlockNumber(context.Context, *BlockNumberRequest) (*BlockNumberResponse, error)
	GetBalance(context.Context, *GetBalanceRequest) (*GetBalanceResponse, error)
	GetStorageAt(context.Context, *GetStorageAtRequest) (*GetStorageAtResponse, error)
	GetTransactionCount(context.Context, *GetTransactionCountRequest) (*GetTransactionCountResponse, error)
	GetBlockTransactionCountByHash(context.Context, *GetBlockTransactionCountByHashRequest) (*GetBlockTransactionCountByHashResponse, error)
	GetBlockTransactionCountByNumber(context.Context, *GetBlockTransactionCountByNumberRequest) (*GetBlockTransactionCountByNumberResponse, error)
	GetUncleCountByBlockHash(context.Context, *GetUncleCountByBlockHashRequest) (*GetUncleCountByBlockHashResponse, error)
	GetUncleCountByBlockNumber(context.Context, *GetUncleCountByBlockNumberRequest) (*GetUncleCountByBlockNumberResponse, error)
	GetCode(context.Context, *GetCodeRequest) (*GetCodeResponse, error)
	SendRawTransaction(context.Context, *SendRawTransactionRequest) (*SendRawTransactionResponse, error)
	Call(context.Context, *CallRequest) (*CallResponse, error)
	EstimateGas(context.Context, *EstimateGasRequest) (*EstimateGasResponse, error)
	GetBlockByHash(context.Context, *GetBlockByHashRequest) (*Block, error)
	GetBlockByNumber(context.Context, *GetBlockByNumberRequest) (*Block, error)
	ListTransactions(context.Context, *ListTransactionsRequest) (*ListTransactionsResponse, error)
	GetTransactionByHash(context.Context, *GetTransactionByHashRequest) (*Transaction, error)
	GetTransactionByBlockHashAndIndex(context.Context, *GetTransactionByBlockHashAndIndexRequest) (*Transaction, error)
	GetTransactionByBlockNumberAndIndex(context.Context, *GetTransactionByBlockNumberAndIndexRequest) (*Transaction, error)
	SubscribeTransactions(*SubscribeTransactionsRequest, Ethereum_SubscribeTransactionsServer) error
	GetTransactionReceipt(context.Context, *GetTransactionReceiptRequest) (*TransactionReceipt, error)
	PendingTransactions(context.Context, *PendingTransactionsRequest) (*PendingTransactionsResponse, error)
	GetUncleByBlockHashAndIndex(context.Context, *GetUncleByBlockHashAndIndexRequest) (*Block, error)
	GetUncleByBlockNumberAndIndex(context.Context, *GetUncleByBlockNumberAndIndexRequest) (*Block, error)
}

// UnimplementedEthereumServer can be embedded to have forward compatible implementations.
type UnimplementedEthereumServer struct {
}

func (*UnimplementedEthereumServer) ProtocolVersion(ctx context.Context, req *ProtocolVersionRequest) (*ProtocolVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProtocolVersion not implemented")
}
func (*UnimplementedEthereumServer) Syncing(ctx context.Context, req *SyncingRequest) (*SyncingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Syncing not implemented")
}
func (*UnimplementedEthereumServer) GasPrice(ctx context.Context, req *GasPriceRequest) (*GasPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GasPrice not implemented")
}
func (*UnimplementedEthereumServer) BlockNumber(ctx context.Context, req *BlockNumberRequest) (*BlockNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockNumber not implemented")
}
func (*UnimplementedEthereumServer) GetBalance(ctx context.Context, req *GetBalanceRequest) (*GetBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (*UnimplementedEthereumServer) GetStorageAt(ctx context.Context, req *GetStorageAtRequest) (*GetStorageAtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageAt not implemented")
}
func (*UnimplementedEthereumServer) GetTransactionCount(ctx context.Context, req *GetTransactionCountRequest) (*GetTransactionCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionCount not implemented")
}
func (*UnimplementedEthereumServer) GetBlockTransactionCountByHash(ctx context.Context, req *GetBlockTransactionCountByHashRequest) (*GetBlockTransactionCountByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockTransactionCountByHash not implemented")
}
func (*UnimplementedEthereumServer) GetBlockTransactionCountByNumber(ctx context.Context, req *GetBlockTransactionCountByNumberRequest) (*GetBlockTransactionCountByNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockTransactionCountByNumber not implemented")
}
func (*UnimplementedEthereumServer) GetUncleCountByBlockHash(ctx context.Context, req *GetUncleCountByBlockHashRequest) (*GetUncleCountByBlockHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUncleCountByBlockHash not implemented")
}
func (*UnimplementedEthereumServer) GetUncleCountByBlockNumber(ctx context.Context, req *GetUncleCountByBlockNumberRequest) (*GetUncleCountByBlockNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUncleCountByBlockNumber not implemented")
}
func (*UnimplementedEthereumServer) GetCode(ctx context.Context, req *GetCodeRequest) (*GetCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCode not implemented")
}
func (*UnimplementedEthereumServer) SendRawTransaction(ctx context.Context, req *SendRawTransactionRequest) (*SendRawTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRawTransaction not implemented")
}
func (*UnimplementedEthereumServer) Call(ctx context.Context, req *CallRequest) (*CallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Call not implemented")
}
func (*UnimplementedEthereumServer) EstimateGas(ctx context.Context, req *EstimateGasRequest) (*EstimateGasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateGas not implemented")
}
func (*UnimplementedEthereumServer) GetBlockByHash(ctx context.Context, req *GetBlockByHashRequest) (*Block, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByHash not implemented")
}
func (*UnimplementedEthereumServer) GetBlockByNumber(ctx context.Context, req *GetBlockByNumberRequest) (*Block, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByNumber not implemented")
}
func (*UnimplementedEthereumServer) ListTransactions(ctx context.Context, req *ListTransactionsRequest) (*ListTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTransactions not implemented")
}
func (*UnimplementedEthereumServer) GetTransactionByHash(ctx context.Context, req *GetTransactionByHashRequest) (*Transaction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByHash not implemented")
}
func (*UnimplementedEthereumServer) GetTransactionByBlockHashAndIndex(ctx context.Context, req *GetTransactionByBlockHashAndIndexRequest) (*Transaction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByBlockHashAndIndex not implemented")
}
func (*UnimplementedEthereumServer) GetTransactionByBlockNumberAndIndex(ctx context.Context, req *GetTransactionByBlockNumberAndIndexRequest) (*Transaction, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByBlockNumberAndIndex not implemented")
}
func (*UnimplementedEthereumServer) SubscribeTransactions(req *SubscribeTransactionsRequest, srv Ethereum_SubscribeTransactionsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTransactions not implemented")
}
func (*UnimplementedEthereumServer) GetTransactionReceipt(ctx context.Context, req *GetTransactionReceiptRequest) (*TransactionReceipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionReceipt not implemented")
}
func (*UnimplementedEthereumServer) PendingTransactions(ctx context.Context, req *PendingTransactionsRequest) (*PendingTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PendingTransactions not implemented")
}
func (*UnimplementedEthereumServer) GetUncleByBlockHashAndIndex(ctx context.Context, req *GetUncleByBlockHashAndIndexRequest) (*Block, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUncleByBlockHashAndIndex not implemented")
}
func (*UnimplementedEthereumServer) GetUncleByBlockNumberAndIndex(ctx context.Context, req *GetUncleByBlockNumberAndIndexRequest) (*Block, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUncleByBlockNumberAndIndex not implemented")
}

func RegisterEthereumServer(s *grpc.Server, srv EthereumServer) {
	s.RegisterService(&_Ethereum_serviceDesc, srv)
}

func _Ethereum_ProtocolVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtocolVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).ProtocolVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/ProtocolVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).ProtocolVersion(ctx, req.(*ProtocolVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_Syncing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).Syncing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/Syncing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).Syncing(ctx, req.(*SyncingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GasPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GasPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GasPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GasPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GasPrice(ctx, req.(*GasPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_BlockNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).BlockNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/BlockNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).BlockNumber(ctx, req.(*BlockNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetBalance(ctx, req.(*GetBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetStorageAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageAtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetStorageAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetStorageAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetStorageAt(ctx, req.(*GetStorageAtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetTransactionCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetTransactionCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetTransactionCount(ctx, req.(*GetTransactionCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetBlockTransactionCountByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockTransactionCountByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetBlockTransactionCountByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetBlockTransactionCountByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetBlockTransactionCountByHash(ctx, req.(*GetBlockTransactionCountByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetBlockTransactionCountByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockTransactionCountByNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetBlockTransactionCountByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetBlockTransactionCountByNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetBlockTransactionCountByNumber(ctx, req.(*GetBlockTransactionCountByNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetUncleCountByBlockHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUncleCountByBlockHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetUncleCountByBlockHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetUncleCountByBlockHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetUncleCountByBlockHash(ctx, req.(*GetUncleCountByBlockHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetUncleCountByBlockNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUncleCountByBlockNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetUncleCountByBlockNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetUncleCountByBlockNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetUncleCountByBlockNumber(ctx, req.(*GetUncleCountByBlockNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetCode(ctx, req.(*GetCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_SendRawTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRawTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).SendRawTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/SendRawTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).SendRawTransaction(ctx, req.(*SendRawTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_Call_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).Call(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/Call",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).Call(ctx, req.(*CallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_EstimateGas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateGasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).EstimateGas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/EstimateGas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).EstimateGas(ctx, req.(*EstimateGasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetBlockByHash(ctx, req.(*GetBlockByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetBlockByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockByNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetBlockByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetBlockByNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetBlockByNumber(ctx, req.(*GetBlockByNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_ListTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).ListTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/ListTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).ListTransactions(ctx, req.(*ListTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetTransactionByHash(ctx, req.(*GetTransactionByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetTransactionByBlockHashAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionByBlockHashAndIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetTransactionByBlockHashAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionByBlockHashAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetTransactionByBlockHashAndIndex(ctx, req.(*GetTransactionByBlockHashAndIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetTransactionByBlockNumberAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionByBlockNumberAndIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetTransactionByBlockNumberAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionByBlockNumberAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetTransactionByBlockNumberAndIndex(ctx, req.(*GetTransactionByBlockNumberAndIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_SubscribeTransactions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeTransactionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EthereumServer).SubscribeTransactions(m, &ethereumSubscribeTransactionsServer{stream})
}

type Ethereum_SubscribeTransactionsServer interface {
	Send(*Transaction) error
	grpc.ServerStream
}

type ethereumSubscribeTransactionsServer struct {
	grpc.ServerStream
}

func (x *ethereumSubscribeTransactionsServer) Send(m *Transaction) error {
	return x.ServerStream.SendMsg(m)
}

func _Ethereum_GetTransactionReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransactionReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetTransactionReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetTransactionReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetTransactionReceipt(ctx, req.(*GetTransactionReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_PendingTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).PendingTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/PendingTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).PendingTransactions(ctx, req.(*PendingTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetUncleByBlockHashAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUncleByBlockHashAndIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetUncleByBlockHashAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetUncleByBlockHashAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetUncleByBlockHashAndIndex(ctx, req.(*GetUncleByBlockHashAndIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ethereum_GetUncleByBlockNumberAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUncleByBlockNumberAndIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthereumServer).GetUncleByBlockNumberAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exowei.ethereum.v1alpha1.Ethereum/GetUncleByBlockNumberAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthereumServer).GetUncleByBlockNumberAndIndex(ctx, req.(*GetUncleByBlockNumberAndIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ethereum_serviceDesc = grpc.ServiceDesc{
	ServiceName: "exowei.ethereum.v1alpha1.Ethereum",
	HandlerType: (*EthereumServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProtocolVersion",
			Handler:    _Ethereum_ProtocolVersion_Handler,
		},
		{
			MethodName: "Syncing",
			Handler:    _Ethereum_Syncing_Handler,
		},
		{
			MethodName: "GasPrice",
			Handler:    _Ethereum_GasPrice_Handler,
		},
		{
			MethodName: "BlockNumber",
			Handler:    _Ethereum_BlockNumber_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _Ethereum_GetBalance_Handler,
		},
		{
			MethodName: "GetStorageAt",
			Handler:    _Ethereum_GetStorageAt_Handler,
		},
		{
			MethodName: "GetTransactionCount",
			Handler:    _Ethereum_GetTransactionCount_Handler,
		},
		{
			MethodName: "GetBlockTransactionCountByHash",
			Handler:    _Ethereum_GetBlockTransactionCountByHash_Handler,
		},
		{
			MethodName: "GetBlockTransactionCountByNumber",
			Handler:    _Ethereum_GetBlockTransactionCountByNumber_Handler,
		},
		{
			MethodName: "GetUncleCountByBlockHash",
			Handler:    _Ethereum_GetUncleCountByBlockHash_Handler,
		},
		{
			MethodName: "GetUncleCountByBlockNumber",
			Handler:    _Ethereum_GetUncleCountByBlockNumber_Handler,
		},
		{
			MethodName: "GetCode",
			Handler:    _Ethereum_GetCode_Handler,
		},
		{
			MethodName: "SendRawTransaction",
			Handler:    _Ethereum_SendRawTransaction_Handler,
		},
		{
			MethodName: "Call",
			Handler:    _Ethereum_Call_Handler,
		},
		{
			MethodName: "EstimateGas",
			Handler:    _Ethereum_EstimateGas_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _Ethereum_GetBlockByHash_Handler,
		},
		{
			MethodName: "GetBlockByNumber",
			Handler:    _Ethereum_GetBlockByNumber_Handler,
		},
		{
			MethodName: "ListTransactions",
			Handler:    _Ethereum_ListTransactions_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _Ethereum_GetTransactionByHash_Handler,
		},
		{
			MethodName: "GetTransactionByBlockHashAndIndex",
			Handler:    _Ethereum_GetTransactionByBlockHashAndIndex_Handler,
		},
		{
			MethodName: "GetTransactionByBlockNumberAndIndex",
			Handler:    _Ethereum_GetTransactionByBlockNumberAndIndex_Handler,
		},
		{
			MethodName: "GetTransactionReceipt",
			Handler:    _Ethereum_GetTransactionReceipt_Handler,
		},
		{
			MethodName: "PendingTransactions",
			Handler:    _Ethereum_PendingTransactions_Handler,
		},
		{
			MethodName: "GetUncleByBlockHashAndIndex",
			Handler:    _Ethereum_GetUncleByBlockHashAndIndex_Handler,
		},
		{
			MethodName: "GetUncleByBlockNumberAndIndex",
			Handler:    _Ethereum_GetUncleByBlockNumberAndIndex_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTransactions",
			Handler:       _Ethereum_SubscribeTransactions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ethereum/v1alpha1/ethereum.proto",
}

func (m *Ether) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ether) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ether) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Eth != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Eth))
		i--
		dAtA[i] = 0x10
	}
	if m.Wei != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Wei))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.R) > 0 {
		i -= len(m.R)
		copy(dAtA[i:], m.R)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.R)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.V) > 0 {
		i -= len(m.V)
		copy(dAtA[i:], m.V)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.V)))
		i--
		dAtA[i] = 0x62
	}
	if m.TransactionIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionIndex))
		i--
		dAtA[i] = 0x58
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x50
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.GasPrice != nil {
		{
			size, err := m.GasPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Gas != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Gas))
		i--
		dAtA[i] = 0x30
	}
	if m.Nonce != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Input) > 0 {
		i -= len(m.Input)
		copy(dAtA[i:], m.Input)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Input)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Topics[iNdEx])
			copy(dAtA[i:], m.Topics[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.Topics[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x32
	}
	if m.TransactionIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TransactionHash) > 0 {
		i -= len(m.TransactionHash)
		copy(dAtA[i:], m.TransactionHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.TransactionHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.LogIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.LogIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransactionReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionReceipt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionReceipt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.LogsBloom) > 0 {
		i -= len(m.LogsBloom)
		copy(dAtA[i:], m.LogsBloom)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.LogsBloom)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Logs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEthereum(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ContractAddress) > 0 {
		i -= len(m.ContractAddress)
		copy(dAtA[i:], m.ContractAddress)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.ContractAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if m.GasUsed != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x40
	}
	if m.CumulativeGasUsed != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.CumulativeGasUsed))
		i--
		dAtA[i] = 0x38
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TransactionIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TransactionHash) > 0 {
		i -= len(m.TransactionHash)
		copy(dAtA[i:], m.TransactionHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.TransactionHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Uncles) > 0 {
		for iNdEx := len(m.Uncles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Uncles[iNdEx])
			copy(dAtA[i:], m.Uncles[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.Uncles[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.TransactionHashes) > 0 {
		for iNdEx := len(m.TransactionHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TransactionHashes[iNdEx])
			copy(dAtA[i:], m.TransactionHashes[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.TransactionHashes[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEthereum(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.GasUsed != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GasLimit != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.GasLimit))
		i--
		dAtA[i] = 0x78
	}
	if m.BlockSize != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockSize))
		i--
		dAtA[i] = 0x70
	}
	if len(m.ExtraData) > 0 {
		i -= len(m.ExtraData)
		copy(dAtA[i:], m.ExtraData)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.ExtraData)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.TotalDifficulty) > 0 {
		i -= len(m.TotalDifficulty)
		copy(dAtA[i:], m.TotalDifficulty)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.TotalDifficulty)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Difficulty) > 0 {
		i -= len(m.Difficulty)
		copy(dAtA[i:], m.Difficulty)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Difficulty)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Miner) > 0 {
		i -= len(m.Miner)
		copy(dAtA[i:], m.Miner)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Miner)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ReceiptsRoot) > 0 {
		i -= len(m.ReceiptsRoot)
		copy(dAtA[i:], m.ReceiptsRoot)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.ReceiptsRoot)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TransactionsRoot) > 0 {
		i -= len(m.TransactionsRoot)
		copy(dAtA[i:], m.TransactionsRoot)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.TransactionsRoot)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LogsBloom) > 0 {
		i -= len(m.LogsBloom)
		copy(dAtA[i:], m.LogsBloom)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.LogsBloom)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Sha3Uncles) > 0 {
		i -= len(m.Sha3Uncles)
		copy(dAtA[i:], m.Sha3Uncles)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Sha3Uncles)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolVersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolVersionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolVersionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolVersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolVersionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolVersionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProtocolVersion != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.ProtocolVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SyncingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HighestBlock != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.HighestBlock))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentBlock != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.CurrentBlock))
		i--
		dAtA[i] = 0x18
	}
	if m.StartingBlock != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.StartingBlock))
		i--
		dAtA[i] = 0x10
	}
	if m.Syncing {
		i--
		if m.Syncing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GasPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GasPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GasPrice != nil {
		{
			size, err := m.GasPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockNumberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BlockNumberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockNumberResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockNumberResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStorageAtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStorageAtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStorageAtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Offset != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStorageAtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStorageAtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStorageAtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransactionCountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionCountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionCountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransactionCountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionCountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionCountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransactionCount != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockTransactionCountByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockTransactionCountByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockTransactionCountByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockTransactionCountByHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockTransactionCountByHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockTransactionCountByHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransactionCount != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockTransactionCountByNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockTransactionCountByNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockTransactionCountByNumberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockTransactionCountByNumberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockTransactionCountByNumberResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockTransactionCountByNumberResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransactionCount != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUncleCountByBlockHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUncleCountByBlockHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUncleCountByBlockHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUncleCountByBlockHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUncleCountByBlockHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUncleCountByBlockHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UncleCount != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.UncleCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUncleCountByBlockNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUncleCountByBlockNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUncleCountByBlockNumberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUncleCountByBlockNumberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUncleCountByBlockNumberResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUncleCountByBlockNumberResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UncleCount != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.UncleCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendRawTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRawTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendRawTransactionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendRawTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRawTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendRawTransactionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TransactionHash) > 0 {
		i -= len(m.TransactionHash)
		copy(dAtA[i:], m.TransactionHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.TransactionHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Transaction != nil {
		{
			size, err := m.Transaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstimateGasRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateGasRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateGasRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Transaction != nil {
		{
			size, err := m.Transaction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstimateGasResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateGasResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateGasResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EstimatedGas != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.EstimatedGas))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IncludeFullTransactions {
		i--
		if m.IncludeFullTransactions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBlockByNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBlockByNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBlockByNumberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IncludeFullTransactions {
		i--
		if m.IncludeFullTransactions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListTransactionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTransactionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PageToken) > 0 {
		i -= len(m.PageToken)
		copy(dAtA[i:], m.PageToken)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.PageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListTransactionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTransactionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTransactionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEthereum(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetTransactionByHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionByHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionByHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TransactionHash) > 0 {
		i -= len(m.TransactionHash)
		copy(dAtA[i:], m.TransactionHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.TransactionHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransactionByBlockHashAndIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionByBlockHashAndIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionByBlockHashAndIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransactionIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransactionByBlockNumberAndIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionByBlockNumberAndIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionByBlockNumberAndIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TransactionIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.TransactionIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeTransactionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeTransactionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransactionReceiptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionReceiptRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransactionReceiptRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TransactionHash) > 0 {
		i -= len(m.TransactionHash)
		copy(dAtA[i:], m.TransactionHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.TransactionHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PendingTransactionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingTransactionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PendingTransactionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingTransactionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingTransactionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Transactions) > 0 {
		for iNdEx := len(m.Transactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Transactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEthereum(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetUncleByBlockHashAndIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUncleByBlockHashAndIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUncleByBlockHashAndIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UncleIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.UncleIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockHash) > 0 {
		i -= len(m.BlockHash)
		copy(dAtA[i:], m.BlockHash)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BlockHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUncleByBlockNumberAndIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUncleByBlockNumberAndIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUncleByBlockNumberAndIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UncleIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.UncleIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEthereum(dAtA []byte, offset int, v uint64) int {
	offset -= sovEthereum(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Ether) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Wei != 0 {
		n += 1 + sovEthereum(uint64(m.Wei))
	}
	if m.Eth != 0 {
		n += 1 + sovEthereum(uint64(m.Eth))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.Input)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovEthereum(uint64(m.Nonce))
	}
	if m.Gas != 0 {
		n += 1 + sovEthereum(uint64(m.Gas))
	}
	if m.GasPrice != nil {
		l = m.GasPrice.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.TransactionIndex != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionIndex))
	}
	l = len(m.V)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.R)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogIndex != 0 {
		n += 1 + sovEthereum(uint64(m.LogIndex))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.TransactionHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.TransactionIndex != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionIndex))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			l = len(s)
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.TransactionIndex != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionIndex))
	}
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.CumulativeGasUsed != 0 {
		n += 1 + sovEthereum(uint64(m.CumulativeGasUsed))
	}
	if m.GasUsed != 0 {
		n += 1 + sovEthereum(uint64(m.GasUsed))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	l = len(m.LogsBloom)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovEthereum(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovEthereum(uint64(m.Number))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.Sha3Uncles)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.LogsBloom)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.TransactionsRoot)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.ReceiptsRoot)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.Miner)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.Difficulty)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.TotalDifficulty)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.ExtraData)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.BlockSize != 0 {
		n += 1 + sovEthereum(uint64(m.BlockSize))
	}
	if m.GasLimit != 0 {
		n += 1 + sovEthereum(uint64(m.GasLimit))
	}
	if m.GasUsed != 0 {
		n += 2 + sovEthereum(uint64(m.GasUsed))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 2 + l + sovEthereum(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 2 + l + sovEthereum(uint64(l))
		}
	}
	if len(m.TransactionHashes) > 0 {
		for _, s := range m.TransactionHashes {
			l = len(s)
			n += 2 + l + sovEthereum(uint64(l))
		}
	}
	if len(m.Uncles) > 0 {
		for _, s := range m.Uncles {
			l = len(s)
			n += 2 + l + sovEthereum(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProtocolVersionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProtocolVersionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolVersion != 0 {
		n += 1 + sovEthereum(uint64(m.ProtocolVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Syncing {
		n += 2
	}
	if m.StartingBlock != 0 {
		n += 1 + sovEthereum(uint64(m.StartingBlock))
	}
	if m.CurrentBlock != 0 {
		n += 1 + sovEthereum(uint64(m.CurrentBlock))
	}
	if m.HighestBlock != 0 {
		n += 1 + sovEthereum(uint64(m.HighestBlock))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GasPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GasPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GasPrice != nil {
		l = m.GasPrice.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockNumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStorageAtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovEthereum(uint64(m.Offset))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStorageAtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionCountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionCountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionCount != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockTransactionCountByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockTransactionCountByHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionCount != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockTransactionCountByNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockTransactionCountByNumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionCount != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUncleCountByBlockHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUncleCountByBlockHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UncleCount != 0 {
		n += 1 + sovEthereum(uint64(m.UncleCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUncleCountByBlockNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUncleCountByBlockNumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UncleCount != 0 {
		n += 1 + sovEthereum(uint64(m.UncleCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendRawTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendRawTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CallRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CallResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EstimateGasRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transaction != nil {
		l = m.Transaction.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EstimateGasResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EstimatedGas != 0 {
		n += 1 + sovEthereum(uint64(m.EstimatedGas))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.IncludeFullTransactions {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBlockByNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.IncludeFullTransactions {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovEthereum(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListTransactionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionByHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionByBlockHashAndIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.TransactionIndex != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionByBlockNumberAndIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.TransactionIndex != 0 {
		n += 1 + sovEthereum(uint64(m.TransactionIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTransactionReceiptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PendingTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PendingTransactionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUncleByBlockHashAndIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockHash)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.UncleIndex != 0 {
		n += 1 + sovEthereum(uint64(m.UncleIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUncleByBlockNumberAndIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if m.UncleIndex != 0 {
		n += 1 + sovEthereum(uint64(m.UncleIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovEthereum(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEthereum(x uint64) (n int) {
	return sovEthereum(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Ether) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ether: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ether: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wei", wireType)
			}
			m.Wei = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wei |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eth", wireType)
			}
			m.Eth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Eth |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = append(m.Input[:0], dAtA[iNdEx:postIndex]...)
			if m.Input == nil {
				m.Input = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gas", wireType)
			}
			m.Gas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GasPrice == nil {
				m.GasPrice = &Ether{}
			}
			if err := m.GasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Ether{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			m.TransactionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.V = append(m.V[:0], dAtA[iNdEx:postIndex]...)
			if m.V == nil {
				m.V = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.R = append(m.R[:0], dAtA[iNdEx:postIndex]...)
			if m.R == nil {
				m.R = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = append(m.S[:0], dAtA[iNdEx:postIndex]...)
			if m.S == nil {
				m.S = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			m.TransactionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionReceipt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			m.TransactionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeGasUsed", wireType)
			}
			m.CumulativeGasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CumulativeGasUsed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &Log{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogsBloom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TransactionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha3Uncles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha3Uncles = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsBloom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogsBloom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionsRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionsRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptsRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiptsRoot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Miner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Difficulty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Difficulty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDifficulty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalDifficulty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraData = append(m.ExtraData[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtraData == nil {
				m.ExtraData = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			m.GasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasLimit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHashes = append(m.TransactionHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uncles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uncles = append(m.Uncles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolVersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolVersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolVersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolVersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolVersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolVersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			m.ProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Syncing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Syncing = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingBlock", wireType)
			}
			m.StartingBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingBlock |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentBlock", wireType)
			}
			m.CurrentBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentBlock |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestBlock", wireType)
			}
			m.HighestBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestBlock |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GasPrice == nil {
				m.GasPrice = &Ether{}
			}
			if err := m.GasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockNumberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockNumberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockNumberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &Ether{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStorageAtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStorageAtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStorageAtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStorageAtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStorageAtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStorageAtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionCountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionCountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionCountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionCountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionCountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionCountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCount", wireType)
			}
			m.TransactionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockTransactionCountByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockTransactionCountByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockTransactionCountByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockTransactionCountByHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockTransactionCountByHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockTransactionCountByHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCount", wireType)
			}
			m.TransactionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockTransactionCountByNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockTransactionCountByNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockTransactionCountByNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockTransactionCountByNumberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockTransactionCountByNumberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockTransactionCountByNumberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCount", wireType)
			}
			m.TransactionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUncleCountByBlockHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUncleCountByBlockHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUncleCountByBlockHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUncleCountByBlockHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUncleCountByBlockHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUncleCountByBlockHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncleCount", wireType)
			}
			m.UncleCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncleCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUncleCountByBlockNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUncleCountByBlockNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUncleCountByBlockNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUncleCountByBlockNumberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUncleCountByBlockNumberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUncleCountByBlockNumberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncleCount", wireType)
			}
			m.UncleCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncleCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRawTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRawTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRawTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRawTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRawTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRawTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateGasRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateGasRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateGasRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transaction == nil {
				m.Transaction = &Transaction{}
			}
			if err := m.Transaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateGasResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateGasResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateGasResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedGas", wireType)
			}
			m.EstimatedGas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EstimatedGas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeFullTransactions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeFullTransactions = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBlockByNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBlockByNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBlockByNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeFullTransactions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeFullTransactions = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTransactionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTransactionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTransactionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTransactionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTransactionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTransactionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionByHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionByHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionByHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionByBlockHashAndIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionByBlockHashAndIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionByBlockHashAndIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			m.TransactionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionByBlockNumberAndIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionByBlockNumberAndIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionByBlockNumberAndIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionIndex", wireType)
			}
			m.TransactionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeTransactionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeTransactionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeTransactionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionReceiptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionReceiptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionReceiptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingTransactionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingTransactionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingTransactionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingTransactionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingTransactionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingTransactionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &Transaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUncleByBlockHashAndIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUncleByBlockHashAndIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUncleByBlockHashAndIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncleIndex", wireType)
			}
			m.UncleIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncleIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUncleByBlockNumberAndIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUncleByBlockNumberAndIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUncleByBlockNumberAndIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncleIndex", wireType)
			}
			m.UncleIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncleIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEthereum(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEthereum
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthEthereum
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEthereum
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEthereum(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthEthereum
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEthereum = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEthereum   = fmt.Errorf("proto: integer overflow")
)
